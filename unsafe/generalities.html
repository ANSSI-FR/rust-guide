<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generalities - Secure Rust Guidelines</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Recommendations for secure applications development with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Secure Rust Guidelines</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="general-information-on-unsafe"><a class="header" href="#general-information-on-unsafe">General information on <code>unsafe</code></a></h1>
<h2 id="unsafe-operations"><a class="header" href="#unsafe-operations"><em>Unsafe</em> operations</a></h2>
<p>Language capabilities can be extended using unsafe code. The full list of these features is given in the <a href="https://doc.rust-lang.org/reference/unsafety.html">Rust reference</a>. Notice the following ones.</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Read or write a mutable or extern static variable</li>
<li>Read a field of an <code>union</code></li>
<li>Implement an <code>unsafe</code> trait</li>
<li>Declare an <code>extern</code> block</li>
</ul>
<p>These capabilities may be necessary for system programming but they cause the language to lose its <a href="../guarantees.html">security properties</a>.</p>
<h2 id="a-keyword-with-two-usages"><a class="header" href="#a-keyword-with-two-usages">A keyword with two usages</a></h2>
<p>The <code>unsafe</code> keyword is used both for marking unsafety in an API and unlocking unsafety in the implementation.</p>
<h3 id="unsafe-marking"><a class="header" href="#unsafe-marking"><code>unsafe</code> marking</a></h3>
<p>Marking with <code>unsafe</code> is a delegation of responsibility with respect to memory safety from the API author to the API user.
The use of this keyword in an API <em>warns</em> the API user about the potential harmful effects of using the API.</p>
<ul>
<li>In a function signature (<a href="https://doc.rust-lang.org/reference/unsafe-keyword.html#r-unsafe.fn">r-unsafe.fn</a>), <code>unsafe</code> means that the behavior of the function may lead to UB if the use of the function does not comply with its interface contract (informally described in its documentation).</li>
<li>In a trait declaration (<a href="https://doc.rust-lang.org/reference/unsafe-keyword.html#r-unsafe.trait">r-unsafe.trait</a>), <code>unsafe</code> means that an erroneous implementation of this trait may lead to UB if the implementation contract (preferably documented) is not respected.</li>
</ul>
<h3 id="unsafe-unlocking"><a class="header" href="#unsafe-unlocking"><code>unsafe</code> unlocking</a></h3>
<p>Unlocking with <code>unsafe</code> means taking responsibility for memory safety from the compiler to the developer.</p>
<p>Using an <code>unsafe</code> block in a function body or in a constant declaration is imposed by the compiler to prevent the <em>inadvertent use</em> of <code>unsafe</code> capabilities like</p>
<ul>
<li>using <code>unsafe</code> tagged functions</li>
<li>modifying static variables</li>
<li>using extern functions</li>
</ul>
<p>Similarly, the implementation of an <code>unsafe</code> trait requires <code>unsafe</code> for the developer to explicitly take into account the memory safety contracts. The keyword <code>unsafe</code> <em>unlocks</em> the implementation of <code>unsafe</code> traits.</p>
<p>Lastly, Since the 2024 edition, <code>unsafe</code> is also required to unlock the following:</p>
<ul>
<li><code>extern</code> blocks, which contain declarations of foreign functions and variables, for <a href="./ffi.html">FFI</a>,</li>
<li>some attributes (for instance , no_mangle, cf. <a href="https://doc.rust-lang.org/reference/attributes.html#r-attributes.safety">r-attributes.safety</a>).</li>
</ul>
<h2 id="limitations-and-precautions"><a class="header" href="#limitations-and-precautions">Limitations and precautions</a></h2>
<p>Paraphrasing the <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>, the fundamental principle of Rust can be summed up as follows:</p>
<blockquote>
<p><code>unsafe</code>-free code cannot go wrong</p>
</blockquote>
<p>The combined use of the type system and the ownership system enforces a high-level memory safety in Rust programs. This way, the language helps prevent memory overflows, null or invalid pointer constructions, and data races.</p>
<p>This promise is valid only if the code does not use <code>unsafe</code> features. When <code>unsafe</code> features are used, the compiler can no longer guarantee memory safety. The developer must then ensure that the code respects the invariants that guarantee memory safety.</p>
<p>That is why it is crucial to limit the use of <code>unsafe</code> features as much as possible:</p>
<blockquote>
<p><strong>Rule <a id="LANG-UNSAFE"></a>LANG-UNSAFE</strong></p>
<p>In a secure Rust development, the <code>unsafe</code> blocks must be avoided. In the following,
we list the only cases where <code>unsafe</code> may be used, provided that they come
with a proper justification:</p>
<ul>
<li>
<p>The Foreign Function Interface (FFI) of Rust allows for describing functions whose implementations are written in C, using the <code>extern "C"</code> prefix. To use such a function, the <code>unsafe</code> keyword is required. “Safe” wrapper shall be defined to safely and seamlessly call C code.</p>
</li>
<li>
<p>For embedded device programming, registers and various other resources are often accessed through a fixed memory address. In this case, <code>unsafe</code> blocks are required to initialize and dereference those particular pointers in Rust. In order to minimize the number of unsafe accesses in the code and to allow easier identification of them by a programmer, a proper abstraction (data
structure or module) shall be provided.</p>
</li>
<li>
<p>A function can be marked unsafe globally (by prefixing its declaration with the <code>unsafe</code> keyword) when it may exhibit unsafe behaviors based on its arguments, that are unavoidable. For instance, this happens when a function tries to dereference a pointer passed as an argument.</p>
</li>
</ul>
<p>With the exception of these cases, <code>#![forbid(unsafe_code)]</code> must appear in the crate root (typically <code>main.rs</code> or <code>lib.rs</code>) to generate compilation errors if <code>unsafe</code> is used in the code base.</p>
</blockquote>
<p>If the use of <code>unsafe</code> is necessary, it is the responsibility of the developer to:</p>
<ul>
<li>ensure that the use of <code>unsafe</code> unlocking does not lead to <em>UB</em>s,</li>
<li>ensure that any <code>unsafe</code> markings are correctly and exhaustively documented so that no <em>UB</em> are possible if the usage conditions (invariants) are respected.</li>
</ul>
<p>Aside from the <code>unsafe</code> code itself, it is also crucial to properly encapsulate the use of <code>unsafe</code> features in a component (crate or module) so as to restore the usual Rust memory safety guarantees:</p>
<blockquote>
<p><strong>Rule <a id="LANG-UNSAFE-ENCP"></a>LANG-UNSAFE-ENCP</strong></p>
<p>In secure development of a Rust software component (crate or module), all
<em>unsafe</em> code must be encapsulated in such a way that:</p>
<ul>
<li>either it exposes a safe behavior to the user, in which no safe interaction
can result in UB (undefined behavior);</li>
<li>or it exposes features marked as unsafe whose usage conditions
(preconditions, sequencing, etc.) are exhaustively documented.</li>
</ul>
</blockquote>
<p>Thus, a function using <code>unsafe</code> operations can be <em>safe</em> if the <code>unsafe</code>
operations do not present any <em>UB</em> (undefined behavior) given the component's
invariants (typically the type invariant for a method). Conversely, a function
without an <code>unsafe</code> block must be marked as <code>unsafe</code> if it breaks these
invariants. The choice and knowledge of these invariants are therefore crucial
for secure development.</p>
<h3 id="example-1-preserving-a-type-invariant"><a class="header" href="#example-1-preserving-a-type-invariant">Example 1: Preserving a type invariant</a></h3>
<p>The following code comes from the <a href="https://doc.rust-lang.org/nomicon/working-with-unsafe.html">Rustonomicon</a>.
It could be used to implement a custom <code>Vec</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr;

pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

// Note this implementation does not correctly handle zero-sized types.
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap { /* reallocate new array with bigger capacity */ }
        unsafe {
            ptr::write(self.ptr.add(self.len), elem);
            self.len += 1;
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>Soundness and safety of this code rely on the fact that bytes from address <code>self.ptr</code> to <code>self.ptr + self.cap * size_of&lt;T&gt;()</code> are allocated.</p>
<p>This invariant can be broken with <em>safe</em> code. For instance</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Vec&lt;T&gt; {
    fn make_room(&amp;mut self) {
        // grow the capacity
        self.cap += 1;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function may be necessary for internal use, but it should not be exposed in the API, or it should be marked with the <code>unsafe</code> keyword, because its use can lead to UB.</p>
<h3 id="example-2-trust-relationship-between-safe-and-unsafe"><a class="header" href="#example-2-trust-relationship-between-safe-and-unsafe">Example 2: Trust relationship between <em>safe</em> and <em>unsafe</em></a></h3>
<p>In the Rust paradigm:</p>
<blockquote>
<p><code>unsafe</code>-free code cannot go wrong</p>
</blockquote>
<p>which means it cannot result in UB.
This property is lost when developers use <em>unsafe</em> code, so they are responsible for not producing UB in any scenario.
Consequently, even <em>safe</em> functions must be handled carefully in <em>unsafe</em> contexts.</p>
<p>Suppose one wants to propose an API to find an object of a given type in memory.
This API could require implementing the following trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Locatable {
    /// Find object of type `Self` in the buffer `buf`.
    /// Returns the index of the first byte representing
    /// an object of type `Self`
    fn locate_instance_into(buf: &amp;[u8]) -&gt; Option&lt;usize&gt;;
}

fn find&lt;T: Locatable&gt;(buf: &amp;[u8]) -&gt; Option&lt;T&gt; {
    let start = T::locate_instance_into(buf)?;
    unsafe {
        let ptr: *const T = buf.as_ptr().add(start).cast();
        Some(ptr.read_unaligned())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This trait can be implemented <strong>without</strong> using <code>unsafe</code>.</p>
<p>For instance, the <code>bool</code> type can implement this trait as follows:</p>
<pre><code class="language-rust ignore align">impl Locatable for bool {
   fn locate_instance_into(buf: &amp;[u8]) -&gt; Option&lt;usize&gt; {
      buf.iter().position(|u| *u == 0 || *u == 1)
   }
}</code></pre>
<div class="warning">
<p>This API is harmful for two reasons:</p>
<ul>
<li>If the <code>Locatable</code> implementation does not give the index of an object of type <code>T</code>, the <code>read_unaligned</code> may produce UB.</li>
<li>If the <code>Locatable</code> implementation gives an out-of-bounds index or an index for which part of the object is out of bounds, the subsequent buffer overflow is UB.</li>
</ul>
</div>
<p>For instance, the following <code>Locatable</code> implementation is incorrect, <strong>but</strong> it is the responsibility of the API author to take it into account.</p>
<pre><pre class="playground"><code class="language-rust align"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Locatable for bool {
   fn locate_instance_into(buf: &amp;[u8]) -&gt; Option&lt;usize&gt; {
      buf.iter().position(|u| *u == 0 || *u == 1).map(|n| n + 100)
   }
}
<span class="boring">}</span></code></pre></pre>
<p>The following program produces UB.</p>
<pre><code class="language-rust ignore align">fn use_locatable() {
   let buf = [4, 1, 99];
   let located_bool: Option&lt;bool&gt; = find(&amp;buf); // UB here!
   println!("{:?}", located_bool)
}</code></pre>
<p>The UB-detecting tool <code>miri</code> reports the following:</p>
<pre><code class="language-default">$ cargo +nightly miri r --bin overflow
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo-miri runner target/miri/x86_64-unknown-linux-gnu/debug/overflow`
error: Undefined Behavior: in-bounds pointer arithmetic failed: attempting to offset pointer by 101 bytes, but got alloc249 which is only 3 bytes from the end of the allocation
  --&gt; src/overflow.rs:16:29
   |
16 |         let ptr: *const T = buf.as_ptr().add(start).cast();
   |                             ^^^^^^^^^^^^^^^^^^^^^^^ Undefined Behavior occurred here
   |
   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior
   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information
help: alloc249 was allocated here:
  --&gt; src/overflow.rs:22:9
   |
22 |     let buf = [4, 1, 99];
   |         ^^^
   = note: BACKTRACE (of the first span):
   = note: inside `find::&lt;bool&gt;` at src/overflow.rs:16:29: 16:52
note: inside `main`
  --&gt; src/overflow.rs:23:38
   |
23 |     let located_bool: Option&lt;bool&gt; = find(&amp;buf); // UB here!
   |                                      ^^^^^^^^^^

note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace

error: aborting due to 1 previous error
</code></pre>
<p>This example shows that developers using <code>unsafe</code> blocks
cannot assume that <em>safe</em> functions or traits they use are well implemented, and thus must prevent UB in case these <em>safe</em> functions have bad behavior.</p>
<p>If they cannot protect their function against poorly implemented <em>safe</em> functions or traits, they have two options:</p>
<ul>
<li>Mark the function they <em>write</em> as <code>unsafe</code>: thus, it is the user's responsibility to provide correct arguments (by checking the <code>unsafe</code> function's documentation).</li>
<li>Mark the traits they <em>use</em> as <code>unsafe</code>: thus, it is the user's responsibility to implement the trait properly (again, by reading the trait documentation).</li>
</ul>
<h4 id="references"><a class="header" href="#references">References</a></h4>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html">https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../unsafe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../unsafe/memory.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../unsafe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../unsafe/memory.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../pagetoc.js"></script>



    </div>
    </body>
</html>
