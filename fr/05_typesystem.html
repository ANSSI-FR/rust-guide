<!DOCTYPE HTML>
<html lang="fr" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Système de types - Développement sécurisé en Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Recommandations pour le développement d&#x27;applications sécurisées en Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Développement sécurisé en Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="système-de-types"><a class="header" href="#système-de-types">Système de types</a></h1>
<!-- ## À propos du système de types de Rust -->
<!--
<mark>TODO</mark> : identifier les pièges du système de types (par exemple,
des confusions à propos du code qui est vraiment exécuté à la suite d'une
résolution de contraintes de traits complexes).
-->
<h2 id="traits-de-la-bibliothèque-standard"><a class="header" href="#traits-de-la-bibliothèque-standard">Traits de la bibliothèque standard</a></h2>
<h3 id="trait-drop--le-destructeur"><a class="header" href="#trait-drop--le-destructeur">Trait <code>Drop</code> : le destructeur</a></h3>
<p>Les types implémentent le trait <code>std::ops::Drop</code> dans le but d'effectuer
certaines opérations lorsque la mémoire associée à une valeur est réclamée.
<code>Drop</code> est l'équivalent Rust d'un destructeur en C++ ou un finaliseur en Java.</p>
<p><code>Drop</code> agit récursivement, depuis la valeur externe vers les valeurs imbriquées.
Lorsqu'une valeur sort du scope (ou est explicitement relâchée avec
<code>std::mem::drop</code>), elle est relâchée en deux étapes. La première étape a lieu
uniquement si le type de la valeur en question implémente le trait <code>Drop</code> et
consiste en l'appel de la méthode <code>drop</code>. La seconde étape consiste en la
répétition de processus de <em>drop</em> récursivement sur tous les champs que contient
la valeur. Il est à noter que l'implémentation de <code>Drop</code> est
<em>responsable uniquement de la valeur extérieure</em>.</p>
<p>Tout d'abord, l'implémentation de <code>Drop</code> ne doit pas être systématique. Elle est
nécessaire uniquement lorsque le type requiert un traitement logique à la
destruction. <code>Drop</code> est typiquement utilisé dans le cas du relâchement des
ressources externes (connexions réseau, fichier, etc.) ou de ressources mémoire
complexes (<em>smart pointers</em> comme les <code>Box</code> ou les <code>Rc</code> par exemple). Au
final, il est probable que l'implémentation du trait <code>Drop</code> contienne des blocs
<code>unsafe</code> ainsi que d'autres opérations critiques du point de vue de la sécurité.</p>
<blockquote>
<p><strong>Recommandation <a id="LANG-DROP"></a>LANG-DROP</strong></p>
<p>Dans un développement sécurisé en Rust, l'implémentation du trait
<code>std::ops::Drop</code> doit être justifiée, documentée et examinée par des pairs.</p>
</blockquote>
<p>Ensuite, le système de types de Rust assure seulement la sûreté mémoire et,
du point de vue du typage, des <code>drop</code>s peuvent tout à fait être manqués.
Plusieurs situations peuvent mener à manquer des <code>drop</code>s, comme :</p>
<ul>
<li>un cycle dans la référence (par exemple avec <code>Rc</code> ou <code>Arc</code>) ;</li>
<li>un appel explicite à <code>std::mem::forget</code> (ou <code>core::mem::forget</code>) (voir
paragraphe à propos de <a href="05_memory.html#forget-et-fuites-de-m%C3%A9moire"><code>forget</code> et des fuites de mémoire</a> ;</li>
<li>un <code>panic</code> dans un <code>drop</code> ;</li>
<li>un arrêt du programme (et un <code>panic</code> lorsque <code>abort-on-panic</code> est activé).</li>
</ul>
<p>Les <code>drop</code>s manqués peuvent mener à l'exposition de données sensibles ou bien
encore à l'épuisement de ressources limitées et par là même à des problèmes
d'indisponibilité.</p>
<blockquote>
<p><strong>Règle <a id="LANG-DROP-NO-PANIC"></a>LANG-DROP-NO-PANIC</strong></p>
<p>Dans un développement sécurisé en Rust, l'implémentation du trait
<code>std::ops::Drop</code> ne doit pas causer de <code>panic</code>.</p>
</blockquote>
<p>En plus des <code>panic</code>s, les <code>drop</code>s contenant du code critique doivent être
protégés.</p>
<blockquote>
<p><strong>Règle <a id="LANG-DROP-NO-CYCLE"></a>LANG-DROP-NO-CYCLE</strong></p>
<p>Les valeurs dont le type implémente <code>Drop</code> ne doivent pas être incluses,
directement ou indirectement, dans un cycle de références à compteurs.</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Recommandation <a id="LANG-DROP-SEC"></a>LANG-DROP-SEC</strong></p>
<p>Certaines opérations liées à la sécurité d'une application à la fin d'un
traitement (comme l'effacement de secrets cryptographiques par exemple) ne
doivent pas reposer uniquement sur l'implémentation du trait <code>Drop</code>.</p>
</blockquote>
<h3 id="les-traits-send-et-sync"><a class="header" href="#les-traits-send-et-sync">Les traits <code>Send</code> et <code>Sync</code></a></h3>
<p>Les traits <code>Send</code> et <code>Sync</code> (définis dans <code>std::marker</code> ou <code>core::marker</code>) sont
des marqueurs utilisés pour assurer la sûreté des accès concurrents en Rust.
Lorsqu'ils sont correctement implémentés, ils permettent au compilateur Rust de
garantir l'absence de problèmes d'accès concurrents. Leurs sémantiques sont
définies comme suit :</p>
<ul>
<li>Un type est <code>Send</code> s’il est sûr d'envoyer (<em>move</em>) des valeurs de ce type vers
un autre fil d'exécution.</li>
<li>Un type est <code>Sync</code> s’il est sûr de partager des valeurs de ce type par une
référence immutable avec un autre fil d'exécution.</li>
</ul>
<p>Ces deux traits sont des traits <em>unsafe</em>, c'est-à-dire que le compilateur Rust
ne vérifie d'aucune manière que leur implémentation est correcte. Le danger est
réel : une implémentation incorrecte peut mener à un <strong>comportement indéfini</strong>.</p>
<p>Heureusement, dans la plupart des cas, il n'est pas nécessaire de fournir une
implémentation. En Rust, la quasi-totalité des types primitifs implémente
<code>Send</code> et <code>Sync</code>, et dans la majorité des cas, Rust fournit de manière
automatique une implémentation pour les types composés. Quelques exceptions
notables sont :</p>
<ul>
<li>les pointeurs <code>raw</code>, qui n'implémentent ni <code>Send</code>, ni <code>Sync</code>, puisqu'ils
n'offrent aucune garantie quant à la sûreté ;</li>
<li>les références <code>UnsafeCell</code>, qui n'implémentent pas <code>Sync</code> (et par extensions,
les références <code>Cell</code> et <code>RefCell</code> non plus), puisqu'elles autorisent la
mutabilité des valeurs contenues (<em>interior mutability</em>) ;</li>
<li>les références <code>Rc</code>, qui n'implémentent ni <code>Send</code>, ni <code>Sync</code>, puisque les
compteurs de références seraient partagés de manière désynchronisée.</li>
</ul>
<p>L'implémentation automatique de <code>Send</code> (respectivement <code>Sync</code>) a lieu pour les
types composés (structures ou énumérations) lorsque tous les champs contenus
implémentent <code>Send</code> (respectivement <code>Sync</code>). Une fonctionnalité notable, mais
<strong>instable</strong>, de Rust (depuis 1.37.0) permet d'empêcher cette implémentation
automatique en annotant explicitement le type considéré avec une
<em>négation d'implementation</em> :</p>
<pre><code class="language-rust ignore noplaypen">#![feature(option_builtin_traits)]

struct SpecialType(u8);
impl !Send for SpecialType {}
impl !Sync for SpecialType {}</code></pre>
<p>L'implémentation négative de <code>Send</code> ou <code>Sync</code> est également utilisée dans la
bibliothèque standard pour les exceptions, et est automatiquement implémentée
lorsque cela est approprié. En résultat, la documentation générée est toujours
explicite : un type implémente soit <code>Send</code> (respectivement <code>Sync</code>), soit
<code>!Send</code> (respectivement <code>!Sync</code>).</p>
<p>En guise d'alternative <em>stable</em> à l'implémentation négative, il est possible
d'utiliser un champ typé par un type fantôme (<code>PhantomData</code>) :</p>
<pre><code class="language-rust noplaypen"><span class="boring">use std::marker::PhantomData;
</span><span class="boring">
</span>struct SpecialType(u8, PhantomData&lt;*const ()&gt;);</code></pre>
<blockquote>
<p><strong>Recommandation <a id="LANG-SYNC-TRAITS"></a>LANG-SYNC-TRAITS</strong></p>
<p>Dans un développement sécurisé en Rust, l'implémentation manuelle des traits
<code>Send</code> et <code>Sync</code> doit être évitée, et, si nécessaire, doit être justifiée,
documentée et révisée par des pairs.</p>
</blockquote>
<h3 id="les-traits-de-comparaison--partialeq-eq-partialord-ord"><a class="header" href="#les-traits-de-comparaison--partialeq-eq-partialord-ord">Les traits de comparaison : <code>PartialEq</code>, <code>Eq</code>, <code>PartialOrd</code>, <code>Ord</code></a></h3>
<p>Les comparaisons (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>) en Rust reposent sur quatre
traits de la bibliothèque standard disponibles dans <code>std::cmp</code> (ou <code>core::cmp</code>
pour une compilation avec <code>no_std</code>) :</p>
<ul>
<li><code>PartialEq&lt;Rhs&gt;</code> qui définit la relation d'équivalence partielle entre objets
de types <code>Self</code> et <code>Rhs</code> ;</li>
<li><code>PartialOrd&lt;Rhs&gt;</code> qui définit la relation d'ordre partiel entre les objets de
types <code>Self</code> et <code>Rhs</code> ;</li>
<li><code>Eq</code> qui définit la relation d'équivalence totale entre les objets du même
type. Il s'agit d'un trait de marquage qui requiert le trait
<code>PartialEq&lt;Self&gt;</code> ;</li>
<li><code>Ord</code> qui définit la relation d'ordre total entre les objets du même type.
Le trait <code>PartialOrd&lt;Self&gt;</code> est alors requis.</li>
</ul>
<p>Comme stipulé dans la documentation de la bibliothèque standard, Rust présuppose
<strong>de nombreux invariants</strong> lors de l'implémentation de ces traits :</p>
<ul>
<li>
<p>Pour <code>PartialEq</code> :</p>
<ul>
<li>
<p><em>Cohérence interne</em> : <code>a.ne(b)</code> est équivalent à <code>!a.eq(b)</code>, c.-à-d., <code>ne</code>
est le strict inverse de <code>eq</code>. Cela correspond précisément à
l'implémentation par défaut de <code>ne</code>.</p>
</li>
<li>
<p><em>Symétrie</em> : <code>a.eq(b)</code> et <code>b.eq(a)</code> sont équivalents. Du point de vue du
développeur, cela signifie que :</p>
<ul>
<li><code>PartialEq&lt;B&gt;</code> est implémenté pour le type <code>A</code> (noté <code>A: PartialEq&lt;B&gt;</code>).</li>
<li><code>PartialEq&lt;A&gt;</code> est implémenté pour le type <code>B</code> (noté <code>B: PartialEq&lt;A&gt;</code>).</li>
<li>Les deux implémentations sont cohérentes l'une avec l'autre.</li>
</ul>
</li>
<li>
<p><em>Transitivité</em> : <code>a.eq(b)</code> et <code>b.eq(c)</code> impliquent <code>a.eq(c)</code>. Cela signifie
que :</p>
<ul>
<li><code>A: PartialEq&lt;B&gt;</code>.</li>
<li><code>B: PartialEq&lt;C&gt;</code>.</li>
<li><code>A: PartialEq&lt;C&gt;</code>.</li>
<li>Les trois implémentations sont cohérentes les unes avec les autres (ainsi
qu'avec leurs implémentations symétriques).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Pour <code>Eq</code> :</p>
<ul>
<li>
<p><code>PartialEq&lt;Self&gt;</code> est implémenté.</p>
</li>
<li>
<p><em>Réflexivité</em> : <code>a.eq(a)</code>. Cela signifie que <code>PartialEq&lt;Self&gt;</code> est
implémenté (<code>Eq</code> ne fournit aucune méthode).</p>
</li>
</ul>
</li>
<li>
<p>Pour <code>PartialOrd</code> :</p>
<ul>
<li>
<p><em>Consistance de la relation d'égalité</em> : <code>a.eq(b)</code> est équivalent à
<code>a.partial_cmp(b) == Some(std::ordering::Eq)</code>.</p>
</li>
<li>
<p><em>Consistence interne</em> :</p>
<ul>
<li><code>a.lt(b)</code> ssi <code>a.partial_cmp(b) == Some(std::ordering::Less)</code>.</li>
<li><code>a.gt(b)</code> ssi <code>a.partial_cmp(b) == Some(std::ordering::Greater)</code>.</li>
<li><code>a.le(b)</code> ssi <code>a.lt(b) || a.eq(b)</code>.</li>
<li><code>a.ge(b)</code> ssi <code>a.gt(b) || a.eq(b)</code>.</li>
</ul>
<p>Il faut noter qu'en définissant seulement <code>partial_cmp</code>, la consistance
interne est garantie par les implémentations par défaut de <code>lt</code>, <code>le</code>, <code>gt</code>,
and <code>ge</code>.</p>
</li>
<li>
<p><em>Antisymétrie</em> : <code>a.lt(b)</code> (respectivement <code>a.gt(b)</code>) implique <code>b.gt(a)</code>
(respectivement <code>b.lt(b)</code>). Du point de vue du développeur, cela signifie
que :</p>
<ul>
<li><code>A: PartialOrd&lt;B&gt;</code>.</li>
<li><code>B: PartialOrd&lt;A&gt;</code>.</li>
<li>Les deux implémentations sont cohérentes l'une avec l'autre.</li>
</ul>
</li>
<li>
<p><em>Transitivité</em> : <code>a.lt(b)</code> et <code>b.lt(c)</code> impliquent <code>a.lt(c)</code> (également avec
<code>gt</code>, <code>le</code> et <code>ge</code>). Cela signifie que :</p>
<ul>
<li><code>A: PartialOrd&lt;B&gt;</code>.</li>
<li><code>B: PartialOrd&lt;C&gt;</code>.</li>
<li><code>A: PartialOrd&lt;C&gt;</code>.</li>
<li>Les trois implémentations sont cohérentes les unes avec les autres (et
avec leurs implémentations symétriques).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Pour <code>Ord</code> :</p>
<ul>
<li>
<p><code>PartialOrd&lt;Self&gt;</code></p>
</li>
<li>
<p><em>Totalité</em> : <code>a.partial_cmp(b) != None</code> est toujours vrai. En d'autres mots,
exactement une assertion parmi <code>a.eq(b)</code>, <code>a.lt(b)</code> et <code>a.gt(b)</code> est vraie.</p>
</li>
<li>
<p><em>Cohérence avec <code>PartialOrd&lt;Self&gt;</code></em>: <code>Some(a.cmp(b)) == a.partial_cmp(b)</code>.</p>
</li>
</ul>
</li>
</ul>
<p>Le compilateur ne vérifie aucun de ces prérequis, à l'exception des
vérifications sur les types. Toutefois, les comparaisons sont des éléments
importants puisqu'elles jouent un rôle tant dans les propriétés de vivacité
des systèmes critiques comme des ordonnanceurs ou des répartiteurs de charge
que dans les algorithmes optimisés qui peuvent éventuellement utiliser des
blocs <code>unsafe</code>. Dans le premier cas d'usage, une mauvaise relation d'ordre
peut causer des problèmes de disponibilité comme des interblocages. Dans le
second cas, cela peut mener à des problèmes classiques de sécurité liés à des
violations de propriétés de sûreté mémoire. C'est là encore un atout que de
limiter au possible l'utilisation des blocs <code>unsafe</code>.</p>
<blockquote>
<p><strong>Règle <a id="LANG-CMP-INV"></a>LANG-CMP-INV</strong></p>
<p>Dans un développement sécurisé en Rust, l'implémentation des traits de
comparaison standards doit respecter les invariants décrits dans la
documentation.</p>
</blockquote>
<blockquote>
<p><strong>Recommandation <a id="LANG-CMP-DEFAULTS"></a>LANG-CMP-DEFAULTS</strong></p>
<p>Dans un développement sécurisé en Rust, l'implémentation des traits de
comparaison standard ne doit être effectuée que par l'implémentation des
méthodes ne fournissant pas d'implémentation par défaut, dans le but de
réduire le risque de violation des invariants associés auxdits traits.</p>
</blockquote>
<p>Il existe un <em>lint</em> Clippy qui permet de vérifier que <code>PartialEq::ne</code> n'est pas
défini lors d'une implémentation du trait <code>PartialEq</code>.</p>
<p>Rust propose une façon de fournir automatiquement des implémentations par défaut
pour les traits de comparaison, au travers de l'attribut <code>#[derive(...)]</code> :</p>
<ul>
<li>La dérivation de <code>PartialEq</code> implémente <code>PartialEq&lt;Self&gt;</code> avec une <strong>égalité
structurelle</strong> à condition que chacun des types des données membres implémente
<code>PartialEq&lt;Self&gt;</code>.</li>
<li>La dérivation de <code>Eq</code> implémente le trait de marquage <code>Eq</code> à condition que
chacun des types des données membres implémente <code>Eq</code>.</li>
<li>La dérivation de <code>PartialOrd</code> implémente <code>PartialOrd&lt;Self&gt;</code> comme un <strong>ordre
lexicographique</strong> à condition que chacun des types des données membres
implémente <code>PartialOrd</code>.</li>
<li>La dérivation de <code>Ord</code> implémente <code>Ord</code> comme un <strong>ordre lexicographique</strong> à
condition que chacun des types des données membres implémente <code>Ord</code>.</li>
</ul>
<p>Par exemple, le court extrait de code suivant montre comment comparer deux
valeurs de type <code>T1</code> facilement. Toutes les assertions sont vraies.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct T1 {
    a: u8, b: u8
}

<span class="boring">fn main() {
</span>assert!(&amp;T1 { a: 0, b: 0 } == Box::new(T1 { a: 0, b: 0 }).as_ref());
assert!(T1 { a: 1, b: 0 } &gt; T1 { a: 0, b: 0 });
assert!(T1 { a: 1, b: 1 } &gt; T1 { a: 1, b: 0 });
<span class="boring">println!("tous les tests sont validés.");
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Attention</strong></p>
<p>La dérivation des traits de comparaison pour les types composites dépend de
<strong>l'ordre de déclaration des champs</strong> et non de leur nom.</p>
<p>D'abord, cela implique que changer l'ordre des champs modifie l'ordre des
valeurs. Par exemple, en considérant le type suivant :</p>
<pre><code class="language-rust noplaypen">#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct T2{
   b: u8, a: u8
};</code></pre>
<p>on a <code>T1 {a: 1, b: 0} &gt; T1 {a: 0, b: 1}</code> mais
<code>T2 {a: 1, b: 0} &lt; T2 {a: 0, b: 1}</code>.</p>
<p>Ensuite, si une comparaison sous-jacente provoque un <code>panic</code>, l'ordre peut
changer le résultat à cause de l'utilisation d'un opérateur logique court-
circuitant dans l'implémentation automatique.</p>
<p>Pour les énumérations, les comparaisons dérivées dépendent d'abord de
<strong>l'ordre des variants</strong>, puis de l'ordre des champs.</p>
</blockquote>
<p>En dépit de ces avertissements sur les ordres dérivés, les comparaisons dérivées
automatiquement sont bien moins sujettes à erreurs que des implémentations
manuelles, et rendent le code plus court et plus simple à maintenir.</p>
<blockquote>
<p><strong>Recommandation <a id="LANG-CMP-DERIVE"></a>LANG-CMP-DERIVE</strong></p>
<p>Dans un développement sécurisé en Rust, l'implémentation des traits de
comparaison standard doit être automatiquement dérivée à l'aide de
<code>#[derive(...)]</code> lorsque l'égalité structurelle et l'ordre lexicographique
sont nécessaires. Toute implémentation manuelle d'un trait de comparaison
standard doit être justifiée et documentée.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="04_language.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="06_unsafe.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="04_language.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="06_unsafe.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
