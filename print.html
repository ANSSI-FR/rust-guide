<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Secure Rust Guidelines</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Recommendations for secure applications development with Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Secure Rust Guidelines</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://www.rust-lang.org">Rust</a> is a multi-paradigm language with a focus on
memory safety.</p>
<p>It aims to be system programming oriented, for instance allowing fine-grained memory
management without garbage collection and without tedious and error-prone
manual memory allocations and deallocations, or preventing data-races.</p>
<p>It achieves this goal by means of
its ownership system (mostly related to variable aliasing). At any point of a
Rust program, the compiler tracks how many variables refer to a given data, and
enforces a set of rules which enable automatic memory management, memory safety
and data-race free programs.</p>
<p>The language also focuses on performance, with powerful compilation
optimizations and language constructs that allow writing <em>zero-cost abstraction</em>
code.</p>
<p>Moreover, the Rust language provides some high-level programming features.
Thanks to higher-order functions, closures, iterators, etc., it allows to write
program parts in the same vein as in functional programming languages.
Besides, static typing discipline, type inference, and ad hoc polymorphism (in
the form of traits) are other ways Rust provides to build libraries and programs
in a safe manner.</p>
<p>Finally, the toolchain (rustup, cargo) greatly facilitate the use of Rust by simplifying
the configuration of the software construction, while giving priority to good compilation
safety practices.</p>
<p>Nevertheless, due to its versatility, the language possibly offers some
constructions that, if not used properly, can introduce security problems,
by making code misinterpreted by the programmer or a reviewer. In addition, as
for every tool in the compilation or software verification field, the tools used
to develop, compile and execute programs can expose certain features or
configurations that, if misused, may lead to vulnerabilities.</p>
<p>Thus, the objective of this document is to compile hints and recommendations to
stay in a safe zone for secure applications development while taking advantage
of the range of possibilities the Rust language can offer.</p>
<h2 id="target-audience"><a class="header" href="#target-audience">Target Audience</a></h2>
<p>The guide intents to group recommendations that should be applied for
application development with strong security level requirements. Anyway, it can
be followed by everyone who wants to ensure that guarantees offered by the Rust
platform are not invalidated due to unsafe, misleading or unclear feature usage.</p>
<p>It is not intended to be a course on how to write Rust programs, there are
already plenty of good learning resources for this purpose
(see for instance the
<a href="https://doc.rust-lang.org">Rust documentation main page</a>).
The purpose is rather to guide the programmer and inform them about some pitfalls
they may encounter.
These recommendations form a complement to the good level of trust
the Rust language already provides. That said, recalls are sometimes necessary
for clarity, and the experienced Rust programmer may rely solely on
highlighted inserts (<em>Rule</em>, <em>Recommendation</em>, <em>Warning</em>, etc.).</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>This guide is written in a collaborative and open manner, via the GitHub
platform
(<a href="https://github.com/ANSSI-FR/rust-guide">https://github.com/ANSSI-FR/rust-guide</a>).
All contributions for future versions are welcome, whether in the form of direct
propositions (<em>pull requests</em>) or in the form of suggestions and discussions
(<em>issues</em>).</p>
<h2 id="structure-of-the-document"><a class="header" href="#structure-of-the-document">Structure of the Document</a></h2>
<p>This document considers separately different phases of a typical (and simplified)
development process.
Firstly, we provide some advices on how to take advantage of using tools of the
Rust ecosystem for secure development.
A following chapter focuses on precautions to take when choosing and using
external libraries.
Then, recommendations about the Rust language constructs are exposed.</p>
<!-- TODO: Finally, we introduce advices for writing
tests for a project in Rust, and for using Rust fuzzing tools.-->
<p>A summary of recommendations presented throughout the document is listed at the
end of this guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-environment"><a class="header" href="#development-environment">Development environment</a></h1>
<h2 id="rustup"><a class="header" href="#rustup">Rustup</a></h2>
<p><a href="https://github.com/rust-lang/rustup.rs">Rustup</a> is the Rust toolchain installer. Among other things, it enables
switching between different flavors of the toolchain (stable, beta, nightly),
managing additional components installation and keeping them up to date.</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>From a security perspective, <code>rustup</code> does perform all downloads over HTTPS,
but does not yet validate signatures of downloads. Protection against
downgrade attacks, certificate pinning, validation of signatures are still
works in progress.
In some cases, it may be preferable to opt for an alternative installation
method listed in the <em>Install</em> section of the official Rust website.</p>
</blockquote>
<h3 id="rust-editions"><a class="header" href="#rust-editions">Rust Editions</a></h3>
<p>Several flavors, called <em>editions</em>, of the Rust language coexist.</p>
<p>The concept of editions has been introduced to clarify new features
implementation and to make them incremental. A new edition will be produced
every two or three years, as stated in the <a href="https://doc.rust-lang.org/edition-guide/">Edition Guide</a>, but this doesn’t
mean that new features and improvements will only be shipped in a new edition.</p>
<p>Some editions bring new keywords and language constructs. Recommendations for
secure applications development then remain closely linked to features of the
language, that are used in such applications, rather than to Rust editions.
In the rest of this guide, best effort will be made to highlight constructions
and language features that are specific to a particular Rust edition.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>No specific edition is recommended, as long as users follow the
recommendations related to the features offered by the edition that has been
chosen.</p>
</blockquote>
<h3 id="stable-nightly-and-beta-toolchains"><a class="header" href="#stable-nightly-and-beta-toolchains">Stable, nightly and beta toolchains</a></h3>
<p>Orthogonally to editions that allow one to select a flavor (a set of features)
of the Rust language, the Rust toolchain is provided in three different
versions, called <em>release channels</em>:</p>
<ul>
<li><em>nightly</em> releases are created once a day,</li>
<li><em>beta</em> releases are created every six weeks, from promoted <em>nightly</em> releases,</li>
<li><em>stable</em> releases are created every six weeks, from promoted <em>beta</em> releases.</li>
</ul>
<p>When playing with different toolchains, it is important to check not only what
the default toolchain is, but also if overrides are currently set for some
directories.</p>
<pre><code class="language-shell">$ pwd
/tmp/foo
$ rustup toolchain list
stable-x86_64-unknown-linux-gnu (default)
beta-x86_64-unknown-linux-gnu
nightly-x86_64-unknown-linux-gnu
$ rustup override list
/tmp/foo                                    nightly-x86_64-unknown-linux-gnu
$
</code></pre>
<blockquote>
<p><strong>Rule <a id="DENV-STABLE"></a>DENV-STABLE</strong></p>
<p>Development of a secure application must be done using a fully stable
toolchain, for limiting potential compiler, runtime or tool bugs.</p>
</blockquote>
<p>When using a specific <code>cargo</code> subcommand that requires a nightly component,
it is preferable to run it by switching the toolchain only locally, instead
of explicitly switching the complete toolchain. For example, to run the
(nightly) latest <code>rustfmt</code>:</p>
<pre><code class="language-shell">$ rustup toolchain list
stable-x86_64-unknown-linux-gnu (default)
beta-x86_64-unknown-linux-gnu
nightly-x86_64-unknown-linux-gnu
$ rustup run nightly cargo fmt
$ # or
$ cargo +nightly fmt
$
</code></pre>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>Once Rustup has set up the appropriate Rust toolchain, <a href="https://doc.rust-lang.org/stable/cargo/">Cargo</a> is available
through the command line program <code>cargo</code>. Cargo is the Rust package manager.
It has a fundamental role in most Rust development:</p>
<ul>
<li>It structures project by providing the project skeleton (<code>cargo new</code>),</li>
<li>It compiles the project (<code>cargo build</code>),</li>
<li>It generates the project's documentation (<code>cargo doc</code>),</li>
<li>It runs tests (<code>cargo test</code>) and benchmarks (<code>cargo bench</code>),</li>
<li>It manages and download dependencies,</li>
<li>It makes packages distributable and publishes them on <a href="https://crates.io">crates.io</a>,</li>
<li>It’s also a front-end to run complementary tools such as those that are
described below, in the form of sub-commands.</li>
</ul>
<blockquote>
<p><strong>Warning</strong></p>
<p>Like <code>rustup</code>, <code>cargo</code> does perform all downloads over HTTPS, but does not
validate the registry index. Ongoing discussions occur on how to best protect
and verify crates. For now, the security relies on the good security of the
website <a href="https://crates.io">crates.io</a> and the GitHub hosted repository containing the
registry index. In some cases, it may be preferable to opt for an alternative
installation method for dependencies.</p>
</blockquote>
<p>Cargo proposes many different commands and options to adapt the build process to
your project needs, mainly through the manifest file <code>Cargo.toml</code>. For a
complete presentation, see <a href="https://doc.rust-lang.org/cargo/index.html">The Cargo Book</a>.</p>
<p>During the development of a secure application, some of the options may require
some attention. The <code>[profile.*]</code> sections allow configuring how the compiler is
invoked. For example:</p>
<ul>
<li>the <code>debug-assertions</code> variable controls whether debug assertions are enabled,</li>
<li>the <code>overflow-checks</code> variable controls whether overflows are checked for
integer arithmetic.</li>
</ul>
<p>Overriding the default options may cause bugs not being detected, even when
using the debug profile that normally enables runtime checks (for example
<a href="./04_language.html#integer-overflows">integer overflow checks</a>).</p>
<blockquote>
<p><strong>Rule <a id="DENV-CARGO-OPTS"></a>DENV-CARGO-OPTS</strong></p>
<p>The variables <code>debug-assertions</code> and <code>overflow-checks</code> must not be overridden
in development profiles sections (<code>[profile.dev]</code> and <code>[profile.test]</code>).</p>
</blockquote>
<p>Cargo proposes other ways to setup its configuration and change its behavior on
a given system. This can be very useful, but it may also be difficult to know
and remember at a given time all the options that are effectively used, and
in particular passed to the compiler. At the end, this can affect the confidence
and robustness of the build process. It is preferable to centralize compiler
options and flags in the configuration file <code>Cargo.toml</code>. For the case of
environment variable <code>RUSTC_WRAPPER</code>, for example, that may be used to generate
part of code or to run external tools before Rust compilation, it is preferable
to use the Cargo build scripts feature.</p>
<blockquote>
<p><strong>Rule <a id="DENV-CARGO-ENVVARS"></a>DENV-CARGO-ENVVARS</strong></p>
<p>The environment variables <code>RUSTC</code>, <code>RUSTC_WRAPPER</code> and <code>RUSTFLAGS</code> must not
be overriden when using Cargo to build the project.</p>
</blockquote>
<h3 id="clippy"><a class="header" href="#clippy">Clippy</a></h3>
<p><a href="https://github.com/rust-lang/rust-clippy">Clippy</a> is a tool that provides and checks many lints (bugs, styling, performance
issues, etc.). Since version 1.29, <code>clippy</code> can be used within the stable
<code>rustup</code> environment. It is recommended to install <code>clippy</code> as a component
(<code>rustup component add clippy</code>) in the stable toolchain instead of installing it
as a project dependency.</p>
<p>The tool comes with some lint categories regarding the kind of issues it aims to
detect. The warnings should be re-checked by the programmer before committing
the fix that is suggested by <code>clippy</code>, especially in the case of lints of the
category <code>clippy::nursery</code> since those hints are still under development.</p>
<blockquote>
<p><strong>Rule <a id="DENV-LINTER"></a>DENV-LINTER</strong></p>
<p>A linter, such as <code>clippy</code>, must be used regularly during the development of
a secure application.</p>
</blockquote>
<h3 id="rustfmt"><a class="header" href="#rustfmt">Rustfmt</a></h3>
<p><a href="https://github.com/rust-lang/rustfmt">Rustfmt</a> is a tool that formats your code according to style guidelines. The
documentation of the tool states some limitations, among others partial support
of macro declarations and uses. One should use the <code>--check</code> option that prints
proposed changes, review these changes, and finally apply them if the code
readability is not affected.</p>
<p>So, to launch it:</p>
<pre><code class="language-shell">$ cargo fmt -- --check
$ # review of the changes
$ cargo fmt
</code></pre>
<p>These guidelines can be customized to your needs by creating a <code>rustfmt.toml</code> or
<code>.rustfmt.toml</code> file at the root of your project. It will be used to override
the default settings, for instance:</p>
<pre><code class="language-toml"># Set the maximum line width to 120
max_width = 120
# Maximum line length for single line if-else expressions
single_line_if_else_max_width = 40
</code></pre>
<p>For more information about the guidelines that <code>rustfmt</code> will check, have a look
at the <a href="https://doc.rust-lang.org/style-guide/index.html">Rust Style Guide</a>.</p>
<blockquote>
<p><strong>Rule <a id="DENV-FORMAT"></a>DENV-FORMAT</strong></p>
<p>The tool <code>rustfmt</code> can be used to ensure that the codebase respects style
guidelines (as described in <code>rustfmt.toml</code> file), with <code>--check</code> option and
manual review.</p>
</blockquote>
<h3 id="rustfix"><a class="header" href="#rustfix">Rustfix</a></h3>
<p>Included with Rust, since the end of 2018, <a href="https://github.com/rust-lang-nursery/rustfix">Rustfix</a> is a tool dedicated in
fixing compiler warnings as well as easing transitions between editions.</p>
<pre><code class="language-shell">$ cargo fix
</code></pre>
<p>To prepare a Rust 2015 project to transition to Rust 2018, one can run:</p>
<pre><code class="language-shell">$ cargo fix --edition
</code></pre>
<p>Rustfix will either fix the code to be compatible with Rust 2018 or print a
warning that explains the problem. This problem will have to be fixed manually.
By running the command (and possibly fixing manually some issues) until there
is no warning, one can ensure the code is compatible with both Rust 2015 and
Rust 2018.</p>
<p>To switch definitely to Rust 2018, one may run:</p>
<pre><code class="language-shell">$ cargo fix --edition-idioms
</code></pre>
<p>Be advised that this tool provides few guarantees on the soundness of the
proposed fixes. In particular mode, some corrections (such as some of those
provided with the <code>--edition-idioms</code>) are known to break the compilation
or change the program semantics in some case.</p>
<blockquote>
<p><strong>Rule <a id="DENV-AUTOFIX"></a>DENV-AUTOFIX</strong></p>
<p>In a secure Rust development, any automatic fix (for instance, provided by
<code>rustfix</code>) must be verified by the developer.</p>
</blockquote>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<p>There exist other useful tools or <code>cargo</code> subcommands for enforcing program
security whether by searching for specific code patterns or by providing
convenient commands for testing or fuzzing. They are discussed in the following
chapters, according to their goals.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p>In addition to the standard library, Rust provides an easy way to import other
libraries in a project, thanks to <code>cargo</code>. The libraries, known as <em>crates</em> in
the Rust ecosystem, are imported from the open-source components central
repository <a href="https://crates.io">crates.io</a>.</p>
<p>It should be noticed that the quality (in terms of security, performances,
readability, etc.) of the published crates is very variable. Moreover, their
maintenance can be irregular or interrupted. The usage of each component from
this repository should be justified, and the developer should validate the
correct application of rules from the current guide in its code. Several tools
can aid in that task.</p>
<h2 id="cargo-outdated"><a class="header" href="#cargo-outdated">Cargo-outdated</a></h2>
<p><a href="https://github.com/kbknapp/cargo-outdated">Cargo-outdated</a> tool allows one to easily manage dependencies versions.</p>
<p>For a given crate, it lists current dependencies versions (using its
<code>Cargo.toml</code>), and checks latest compatible version and also latest general
version.</p>
<blockquote>
<p><strong>Rule <a id="LIBS-OUTDATED"></a>LIBS-OUTDATED</strong></p>
<p>The <code>cargo-outdated</code> tool must be used to check dependencies status. Then,
each outdated dependency must be updated or the choice of the version must be
justified.</p>
</blockquote>
<h2 id="cargo-audit"><a class="header" href="#cargo-audit">Cargo-audit</a></h2>
<p><a href="https://github.com/RustSec/cargo-audit">Cargo-audit</a> tool allows one to easily check for security vulnerabilities
reported to the RustSec Advisory Database.</p>
<blockquote>
<p><strong>Rule <a id="LIBS-AUDIT"></a>LIBS-AUDIT</strong></p>
<p>The <code>cargo-audit</code> tool must be used to check for known vulnerabilities in
dependencies.</p>
</blockquote>
<!-- ## Unsafe code in libraries -->
<!--
<mark>TODO</mark>: `unsafe` blocks are discussed in the following chapter.
One needs to ensure that this kind of block is not misused in project
dependencies.
-->
<!--
> **Recommendation <a id="LIBS-UNSAFE"></a>LIBS-UNSAFE**
>
> <mark>TODO</mark>: check that no `unsafe` blocks appear in the imported
> dependencies (with a tool?).
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-generalities"><a class="header" href="#language-generalities">Language generalities</a></h1>
<h2 id="language-guarantees"><a class="header" href="#language-guarantees">Language guarantees</a></h2>
<h3 id="undefined-behaviors-ub"><a class="header" href="#undefined-behaviors-ub">Undefined Behaviors (<em>UB</em>)</a></h3>
<blockquote>
<p>The behavior of a program is <em>undefined</em> when its semantics is not described in the Rust language.</p>
</blockquote>
<p>The existence of UB is considered an <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#r-undefined.general">error</a>.</p>
<p>For example, dereferencing the null pointer is a <em>UB</em>. On the other hand, <code>unwrap</code>ing the <code>None</code> object is well defined because it is the language that processes this error (by launching a panic).</p>
<p>The current list of <em>UBs</em> is given in the language <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">reference</a>. Notice the following guarantees:</p>
<ul>
<li>No dereference of pointer to an unallocated or unaligned memory address (dangling pointer), which implies
<ul>
<li>No buffer overflow</li>
<li>No access to freed memory</li>
<li>No non-aligned access</li>
</ul>
</li>
<li>The pointed values are <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#r-undefined.invalid">consistent</a> with the pointer's type. For example, a value pointed at by a boolean pointer will be byte of value 1 or 0.</li>
<li>Respect of <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#r-undefined.alias">aliasing rules</a> (see also <a href="https://doc.rust-lang.org/nomicon/aliasing.html">nomicon</a>): a mutable reference cannot be shared.</li>
<li>No concurrent access (reading/writing is not possible while writing) to the same memory address (<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#r-undefined.race">data race</a>, see also <a href="https://doc.rust-lang.org/nomicon/races.html">nomicon</a>)</li>
</ul>
<h3 id="rust-guarantees"><a class="header" href="#rust-guarantees">Rust guarantees</a></h3>
<blockquote>
<p>The language paradigm is to ensure the absence of a UB in a program using only the non-<em>unsafe</em> part of Rust.</p>
</blockquote>
<p>However, the language does not prevent</p>
<ul>
<li>resource leaks (memory, IO, ...),</li>
<li>numeric overflows.</li>
</ul>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<ul>
<li>https://doc.rust-lang.org/reference/unsafety.html</li>
<li>https://doc.rust-lang.org/nomicon/what-unsafe-does.html</li>
</ul>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>As of now, the standard library is the de facto standard for naming things in
the Rust world. However, an effort has been made to formalize it, first in
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 430</a>, then in the <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a>.</p>
<p>The basic rule consists in using :</p>
<ul>
<li><code>UpperCamelCase</code> for types, traits, enum variants,</li>
<li><code>snake_case</code> for functions, methods, macros, variables and modules,</li>
<li><code>SCREAMING_SNAKE_CASE</code> for statics and constants,</li>
<li><code>'lowercase</code> for lifetimes.</li>
</ul>
<p>The <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a> also prescribes more precise naming conventions for
some particular constructions:</p>
<ul>
<li>(C-CONV) for conversion methods (<code>as_</code>, <code>to_</code>, <code>into_</code>),</li>
<li>(C-GETTER) for getters,</li>
<li>(C-ITER) for iterator-producing methods,</li>
<li>(C-ITER-TY) for iterator types,</li>
<li>(C-FEATURE) for feature naming,</li>
<li>(C-WORD-ORDER) for word order consistency.</li>
</ul>
<blockquote>
<p><strong>Rule <a id="LANG-NAMING"></a>LANG-NAMING</strong></p>
<p>Development of a secure application must follow the naming conventions
outlined in the <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a>.</p>
</blockquote>
<h2 id="integer-overflows"><a class="header" href="#integer-overflows">Integer overflows</a></h2>
<p>Although some verification is performed by Rust regarding potential integer
overflows, precautions should be taken when executing arithmetic operations on
integers.</p>
<p>In particular, it should be noted that using debug or release compilation
profile changes integer overflow behavior. In debug configuration, overflow
cause the termination of the program (<code>panic</code>), whereas in the release
configuration the computed value silently wraps around the maximum value that
can be stored.</p>
<p>This last behavior can be made explicit by using the <code>Wrapping</code> generic type,
or the <code>overflowing_&lt;op&gt;</code> and <code>wrapping_&lt;op&gt;</code> operations on integers
(the <code>&lt;op&gt;</code> part being <code>add</code>, <code>mul</code>, <code>sub</code>, <code>shr</code>, etc.).</p>
<pre><pre class="playground"><code class="language-rust">use std::num::Wrapping;
<span class="boring">use std::panic;
</span>
<span class="boring">fn main() {
</span>let x: u8 = 242;

<span class="boring">let result = panic::catch_unwind(|| {
</span>println!("{}", x + 50);                      // panics in debug, prints 36 in release.
<span class="boring">});
</span><span class="boring">if result.is_err() { println!("panic"); }
</span>println!("{}", x.overflowing_add(50).0);     // always prints 36.
println!("{}", x.wrapping_add(50));          // always prints 36.
println!("{}", Wrapping(x) + Wrapping(50));  // always prints 36.

// always panics:
let (res, c) = x.overflowing_add(50);
<span class="boring">let result = panic::catch_unwind(|| {
</span>if c { panic!("custom error"); }
else { println!("{}", res); }
<span class="boring">});
</span><span class="boring">if result.is_err() { println!("panic"); }
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Rule <a id="LANG-ARITH"></a>LANG-ARITH</strong></p>
<p>When assuming that an arithmetic operation can produce an overflow, the
specialized functions <code>overflowing_&lt;op&gt;</code>, <code>wrapping_&lt;op&gt;</code>, or the
<code>Wrapping</code> type must be used.</p>
</blockquote>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<!-- <mark>TODO</mark>: explicit good practices in error handling. -->
<p>The <code>Result</code> type is the preferred way of handling functions that can fail.
A <code>Result</code> object must be tested, and never ignored.</p>
<blockquote>
<p><strong>Recommendation <a id="LANG-ERRWRAP"></a>LANG-ERRWRAP</strong></p>
<p>A crate can implement its own <code>Error</code> type, wrapping all possible errors.
It must be careful to make this type exception-safe (RFC 1236), and implement
<code>Error + Send + Sync + 'static</code> as well as <code>Display</code>.</p>
</blockquote>
<blockquote>
<p><strong>Recommendation <a id="LANG-ERRDO"></a>LANG-ERRDO</strong></p>
<p>The <code>?</code> operator should be used to improve readability of code.
The <code>try!</code> macro should not be used.</p>
</blockquote>
<p>Third-party crates may be used to facilitate error handling. Most of them
(notably <a href="https://crates.io/crates/failure">failure</a>, <a href="https://crates.io/crates/snafu">snafu</a>, <a href="https://crates.io/crates/thiserror">thiserror</a>) address the creation of new custom
error types that implement the necessary traits and allow wrapping other
errors.</p>
<p>Another approach (notably proposed in the <a href="https://crates.io/crates/anyhow">anyhow</a> crate) consists in an automatic
wrapping of errors into a single universal error type. Such wrappers should not
be used in libraries and complex systems because they do not allow developers to
provide context to the wrapped error.</p>
<h3 id="panics"><a class="header" href="#panics">Panics</a></h3>
<p>Explicit error handling (<code>Result</code>) should always be preferred instead of calling
<code>panic</code>.  The cause of the error should be available, and generic errors should
be avoided.</p>
<p>Crates providing libraries should never use functions or instructions that can
fail and cause the code to panic.</p>
<p>Common patterns that can cause panics are:</p>
<ul>
<li>using <code>unwrap</code> or <code>expect</code>,</li>
<li>using <code>assert</code>,</li>
<li>an unchecked access to an array,</li>
<li>integer overflow (in debug mode),</li>
<li>division by zero,</li>
<li>large allocations,</li>
<li>string formatting using <code>format!</code>.</li>
</ul>
<blockquote>
<p><strong>Rule <a id="LANG-NOPANIC"></a>LANG-NOPANIC</strong></p>
<p>Functions or instructions that can cause the code to panic at runtime must not
be used.</p>
</blockquote>
<blockquote>
<p><strong>Rule <a id="LANG-ARRINDEXING"></a>LANG-ARRINDEXING</strong></p>
<p>Array indexing must be properly tested, or the <code>get</code> method should be used to
return an <code>Option</code>.</p>
</blockquote>
<!--
<mark>TODO</mark> Check if the [no_panic](https://github.com/dtolnay/no-panic)
crate can catch all cases. Drawback: all functions need to be marked as
`#[no_panic]`.
-->
<!--
<mark>TODO</mark> Another possibility:
[rustig](https://github.com/Technolution/rustig) (doesn't build here)
-->
<h3 id="ffi-and-panics"><a class="header" href="#ffi-and-panics">FFI and panics</a></h3>
<p>When calling Rust code from another language (for ex. C), the Rust code must
be careful to never panic.
Stack unwinding from Rust code into foreign code results in undefined behavior.</p>
<blockquote>
<p><strong>Rule <a id="LANG-FFIPANIC"></a>LANG-FFIPANIC</strong></p>
<p>Rust code called from FFI must either ensure the function cannot panic, or use
<code>catch_unwind</code> or the <code>std::panic</code> module to ensure the rust code will not
abort or return in an unstable state.</p>
</blockquote>
<p>Note that <code>catch_unwind</code> will only catch unwinding panics, not those that abort
the process.</p>
<!-- ## Macros -->
<!--
<mark>TODO</mark>: cyclomatic complexity of the macro expanded code, recursion
limits, ...
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system"><a class="header" href="#type-system">Type system</a></h1>
<!-- ## About Rust type system -->
<!--
<mark>TODO</mark>: identify pitfalls with the type system (for instance,
misunderstanding of which code is actually executed when implementing complex
patterns with traits).
-->
<h2 id="standard-library-traits"><a class="header" href="#standard-library-traits">Standard library traits</a></h2>
<h3 id="drop-trait-the-destructor"><a class="header" href="#drop-trait-the-destructor"><code>Drop</code> trait, the destructor</a></h3>
<p>Types implement the trait <code>std::ops::Drop</code> to perform some operations when the
memory associated with a value of this type is to be reclaimed. <code>Drop</code> is the
Rust equivalent of a destructor in C++ or a finalizer in Java.</p>
<p>Dropping is done recursively from the outer value to the inner values.
When a value goes out of scope (or is explicitly dropped with <code>std::mem::drop</code>),
the value is dropped in two steps. The first step happens only if the type of
this value implements <code>Drop</code>. It consists in calling the <code>drop</code> method on it.
The second step consists in repeating the dropping process recursively on any
field the value contains. Note that a <code>Drop</code> implementation is
<strong>only responsible for the outer value</strong>.</p>
<p>First and foremost, implementing <code>Drop</code> should not be systematic.
It is only needed if the type requires some destructor logic. In fact, <code>Drop</code> is
typically used to release external resources (network connections, files, etc.)
or to release memory (e.g. in smart pointers such as <code>Box</code> or <code>Rc</code>).
As a result, <code>Drop</code> trait implementations are likely to contain <code>unsafe</code> code
blocks as well as other security-critical operations.</p>
<blockquote>
<p><strong>Recommendation <a id="LANG-DROP"></a>LANG-DROP</strong></p>
<p>In a Rust secure development, the implementation of the <code>std::ops::Drop</code> trait
should be justified, documented and peer-reviewed.</p>
</blockquote>
<p>Second, Rust type system only ensures memory safety and, from the type system's
standpoint, missing drops is allowed. In fact, several things may lead to
missing drops, such as:</p>
<ul>
<li>a reference cycle (for instance, with <code>Rc</code> or <code>Arc</code>),</li>
<li>an explicit call to <code>std::mem::forget</code> (or <code>core::mem::forget</code>) (see paragraph
on <a href="05_memory.html#forget-and-memory-leaks">Forget and memory leaks</a>,</li>
<li>a panic in drop,</li>
<li>program aborts (and panics when abort-on-panic is on).</li>
</ul>
<p>And missing drops may lead to exposing sensitive data or to lock limited
resources leading to unavailability issues.</p>
<blockquote>
<p><strong>Rule <a id="LANG-DROP-NO-PANIC"></a>LANG-DROP-NO-PANIC</strong></p>
<p>In a Rust secure development, the implementation of the <code>std::ops::Drop</code> trait
must not panic.</p>
</blockquote>
<p>Beside panics, secure-critical drop should be protected.</p>
<blockquote>
<p><strong>Rule <a id="LANG-DROP-NO-CYCLE"></a>LANG-DROP-NO-CYCLE</strong></p>
<p>Value whose type implements <code>Drop</code> must not be embedded directly or indirectly
in a cycle of reference-counted references.</p>
</blockquote>
<blockquote>
<p><strong>Recommendation <a id="LANG-DROP-SEC"></a>LANG-DROP-SEC</strong></p>
<p>Ensuring security operations at the end of some treatment (such as key erasure
at the end of a cryptographic encryption) should not rely only on the <code>Drop</code>
trait implementation.</p>
</blockquote>
<h3 id="send-and-sync-traits"><a class="header" href="#send-and-sync-traits"><code>Send</code> and <code>Sync</code> traits</a></h3>
<p>The <code>Send</code> and <code>Sync</code> traits (defined in <code>std::marker</code> or <code>core::marker</code>) are
marker traits used to ensure the safety of concurrency in Rust. When implemented
correctly, they allow the Rust compiler to guarantee the absence of data races.
Their semantics is as follows:</p>
<ul>
<li>A type is <code>Send</code> if it is safe to send (move) it to another thread.</li>
<li>A type is <code>Sync</code> if it is safe to share a immutable reference to it with
another thread.</li>
</ul>
<p>Both traits are <em>unsafe traits</em>, i.e., the Rust compiler does not verify in any
way that they are implemented correctly. The danger is real: an incorrect
implementation may lead to <strong>undefined behavior</strong>.</p>
<p>Fortunately, in most cases, one does not need to implement it. In Rust,
almost all primitive types are <code>Send</code> and <code>Sync</code>, and for most compound types
the implementation is automatically provided by the Rust compiler.
Notable exceptions are:</p>
<ul>
<li>Raw pointers are neither <code>Send</code> nor <code>Sync</code> because they offer no safety
guards.</li>
<li><code>UnsafeCell</code> is not <code>Sync</code> (and as a result <code>Cell</code> and <code>RefCell</code> aren't
either) because they offer interior mutability (mutably shared value).</li>
<li><code>Rc</code> is neither <code>Send</code> nor <code>Sync</code> because the reference counter is shared and
unsynchronized.</li>
</ul>
<p>Automatic implementation of <code>Send</code> (resp. <code>Sync</code>) occurs for a compound type
(structure or enumeration) when all fields have <code>Send</code> types (resp. <code>Sync</code>
types). Using an unstable feature (as of Rust 1.37.0), one can block the
automatic implementation of those traits with a manual
<em>negative implementation</em>:</p>
<pre><code class="language-rust ignore noplaypen">#![feature(option_builtin_traits)]

struct SpecialType(u8);
impl !Send for SpecialType {}
impl !Sync for SpecialType {}</code></pre>
<p>The negative implementation of <code>Send</code> or <code>Sync</code> are also used in the standard
library for the exceptions, and are automatically implemented when appropriate.
As a result, the generated documentation is always explicit: a type implements
either <code>Send</code> or <code>!Send</code> (resp. <code>Sync</code> or <code>!Sync</code>).</p>
<p>As a stable alternative to negative implementation, one can use a <code>PhantomData</code>
field:</p>
<pre><code class="language-rust noplaypen"><span class="boring">use std::marker::PhantomData;
</span><span class="boring">
</span>struct SpecialType(u8, PhantomData&lt;*const ()&gt;);</code></pre>
<blockquote>
<p><strong>Recommendation <a id="LANG-SYNC-TRAITS"></a>LANG-SYNC-TRAITS</strong></p>
<p>In a Rust secure development, the manual implementation of the <code>Send</code> and
<code>Sync</code> traits should be avoided and, if necessary, should be justified,
documented and peer-reviewed.</p>
</blockquote>
<h3 id="comparison-traits-partialeq-eq-partialord-ord"><a class="header" href="#comparison-traits-partialeq-eq-partialord-ord">Comparison traits (<code>PartialEq</code>, <code>Eq</code>, <code>PartialOrd</code>, <code>Ord</code>)</a></h3>
<p>Comparisons (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>) in Rust relies on four standard
traits available in <code>std::cmp</code> (or <code>core::cmp</code> for <code>no_std</code> compilation):</p>
<ul>
<li><code>PartialEq&lt;Rhs&gt;</code> that defines a partial equivalence between
objects of types <code>Self</code> and <code>Rhs</code>,</li>
<li><code>PartialOrd&lt;Rhs&gt;</code> that defines a partial order between objects of types
<code>Self</code> and <code>Rhs</code>,</li>
<li><code>Eq</code> that defines a total equivalence between objects of the same
type. It is only a marker trait that requires <code>PartialEq&lt;Self&gt;</code>!</li>
<li><code>Ord</code> that defines the total order between objects of the same type.
It requires that <code>PartialOrd&lt;Self&gt;</code> is implemented.</li>
</ul>
<p>As documented in the standard library, Rust assumes <strong>a lot of invariants</strong>
about the implementations of those traits:</p>
<ul>
<li>
<p>For <code>PartialEq</code></p>
<ul>
<li>
<p><em>Internal consistency</em>: <code>a.ne(b)</code> is equivalent to <code>!a.eq(b)</code>, i.e., <code>ne</code> is
the strict inverse of <code>eq</code>. The default implementation of <code>ne</code> is precisely
that.</p>
</li>
<li>
<p><em>Symmetry</em>: <code>a.eq(b)</code> and <code>b.eq(a)</code>, are equivalent. From the developer's
point of view, it means:</p>
<ul>
<li><code>PartialEq&lt;B&gt;</code> is implemented for type <code>A</code> (noted <code>A: PartialEq&lt;B&gt;</code>),</li>
<li><code>PartialEq&lt;A&gt;</code> is implemented for type <code>B</code> (noted <code>B: PartialEq&lt;A&gt;</code>),</li>
<li>both implementations are consistent with each other.</li>
</ul>
</li>
<li>
<p><em>Transitivity</em>: <code>a.eq(b)</code> and <code>b.eq(c)</code> implies <code>a.eq(c)</code>. It means that:</p>
<ul>
<li><code>A: PartialEq&lt;B&gt;</code>,</li>
<li><code>B: PartialEq&lt;C&gt;</code>,</li>
<li><code>A: PartialEq&lt;C&gt;</code>,</li>
<li>the three implementations are consistent with each other (and their
symmetric implementations).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>For <code>Eq</code></p>
<ul>
<li>
<p><code>PartialEq&lt;Self&gt;</code> is implemented.</p>
</li>
<li>
<p><em>Reflexivity</em>: <code>a.eq(a)</code>. This stands for <code>PartialEq&lt;Self&gt;</code> (<code>Eq</code> does not
provide any method).</p>
</li>
</ul>
</li>
<li>
<p>For <code>PartialOrd</code></p>
<ul>
<li>
<p><em>Equality consistency</em>:
<code>a.eq(b)</code> is equivalent to <code>a.partial_cmp(b) == Some(std::ordering::Eq)</code>.</p>
</li>
<li>
<p><em>Internal consistency</em>:</p>
<ul>
<li><code>a.lt(b)</code> iff <code>a.partial_cmp(b) == Some(std::ordering::Less)</code>,</li>
<li><code>a.gt(b)</code> iff <code>a.partial_cmp(b) == Some(std::ordering::Greater)</code>,</li>
<li><code>a.le(b)</code> iff <code>a.lt(b) || a.eq(b)</code>,</li>
<li><code>a.ge(b)</code> iff <code>a.gt(b) || a.eq(b)</code>.</li>
</ul>
<p>Note that by only defining <code>partial_cmp</code>, the internal consistency is
guaranteed by the default implementation of <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>.</p>
</li>
<li>
<p><em>Antisymmetry</em>: <code>a.lt(b)</code> (respectively <code>a.gt(b)</code>) implies <code>b.gt(a)</code>
(respectively, <code>b.lt(b)</code>). From the developer's standpoint, it also means:</p>
<ul>
<li><code>A: PartialOrd&lt;B&gt;</code>,</li>
<li><code>B: PartialOrd&lt;A&gt;</code>,</li>
<li>both implementations are consistent with each other.</li>
</ul>
</li>
<li>
<p><em>Transitivity</em>: <code>a.lt(b)</code> and <code>b.lt(c)</code> implies <code>a.lt(c)</code> (also with <code>gt</code>,
<code>le</code> and <code>ge</code>). It also means:</p>
<ul>
<li><code>A: PartialOrd&lt;B&gt;</code>,</li>
<li><code>B: PartialOrd&lt;C&gt;</code>,</li>
<li><code>A: PartialOrd&lt;C&gt;</code>,</li>
<li>the implementations are consistent with each other (and their symmetric).</li>
</ul>
</li>
</ul>
</li>
<li>
<p>For <code>Ord</code></p>
<ul>
<li>
<p><code>PartialOrd&lt;Self&gt;</code></p>
</li>
<li>
<p><em>Totality</em>: <code>a.partial_cmp(b) != None</code> always. In other words,
exactly one of <code>a.eq(b)</code>, <code>a.lt(b)</code>, <code>a.gt(b)</code> is true.</p>
</li>
<li>
<p><em>Consistency with <code>PartialOrd&lt;Self&gt;</code></em>: <code>Some(a.cmp(b)) == a.partial_cmp(b)</code>.</p>
</li>
</ul>
</li>
</ul>
<p>The compiler do not check any of those requirements except for the type checking
itself. However, comparisons are critical because they intervene both in
liveness critical systems such as schedulers and load balancers, and in
optimized algorithms that may use <code>unsafe</code> blocks.
In the first use, a bad ordering may lead to availability issues such as
deadlocks.
In the second use, it may lead to classical security issues linked to memory
safety violations. That is again a factor in the practice of limiting the use
of <code>unsafe</code> blocks.</p>
<blockquote>
<p><strong>Rule <a id="LANG-CMP-INV"></a>LANG-CMP-INV</strong></p>
<p>In a Rust secure development, the implementation of standard comparison traits
must respect the invariants described in the documentation.</p>
</blockquote>
<blockquote>
<p><strong>Recommendation <a id="LANG-CMP-DEFAULTS"></a>LANG-CMP-DEFAULTS</strong></p>
<p>In a Rust secure development, the implementation of standard comparison traits
should only define methods with no default implementation, so as to reduce
the risk of violating the invariants associated with the traits.</p>
</blockquote>
<p>There is a Clippy lint to check that <code>PartialEq::ne</code> is not defined in
<code>PartialEq</code> implementations.</p>
<p>Rust comes with a standard way to automatically construct implementations of the
comparison traits through the <code>#[derive(...)]</code> attribute:</p>
<ul>
<li>Derivation <code>PartialEq</code> implements <code>PartialEq&lt;Self&gt;</code> with a
<strong>structural equality</strong> providing that each subtype is <code>PartialEq&lt;Self&gt;</code>.</li>
<li>Derivation <code>Eq</code> implements the <code>Eq</code> marker trait providing that each subtype
is <code>Eq</code>.</li>
<li>Derivation <code>PartialOrd</code> implements <code>PartialOrd&lt;Self&gt;</code> as a
<strong>lexicographical order</strong> providing that each subtype is <code>PartialOrd</code>.</li>
<li>Derivation <code>Ord</code> implements <code>Ord</code> as a <strong>lexicographical order</strong>
providing that each subtype is <code>Ord</code>.</li>
</ul>
<p>For instance, the short following code shows how to compare two <code>T1</code>s easily.
All the assertions hold.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct T1 {
    a: u8, b: u8
}

<span class="boring">fn main() {
</span>assert!(&amp;T1 { a: 0, b: 0 } == Box::new(T1 { a: 0, b: 0 }).as_ref());
assert!(T1 { a: 1, b: 0 } &gt; T1 { a: 0, b: 0 });
assert!(T1 { a: 1, b: 1 } &gt; T1 { a: 1, b: 0 });
<span class="boring">println!("all tests passed.");
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Warning</strong></p>
<p>Derivation of comparison traits for compound types depends on the
<strong>field order</strong>, and not on their names.</p>
<p>First, it means that changing the order of declaration of two fields change
the resulting lexicographical order. For instance, provided this second
ordered type:</p>
<pre><code class="language-rust noplaypen">#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct T2{
   b: u8, a: u8
};</code></pre>
<p>we have <code>T1 {a: 1, b: 0} &gt; T1 {a: 0, b: 1}</code> but
<code>T2 {a: 1, b: 0} &lt; T2 {a: 0, b: 1}</code>.</p>
<p>Second, if one of the underlying comparison panics, the order may change the
result due to the use of short-circuit logic in the automatic implementation.</p>
<p>For enums, the derived comparisons depends first on the <strong>variant order</strong> then
on the field order.</p>
</blockquote>
<p>Despite the ordering caveat, derived comparisons are a lot less error-prone
than manual ones and makes code shorter and easier to maintain.</p>
<blockquote>
<p><strong>Recommendation <a id="LANG-CMP-DERIVE"></a>LANG-CMP-DERIVE</strong></p>
<p>In a secure Rust development, the implementation of standard comparison traits
should be automatically derived with <code>#[derive(...)]</code> when structural equality
and lexicographical comparison is needed. Any manual implementation of
standard comparison traits should be documented and justified.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-unsafe"><a class="header" href="#rust-unsafe">Rust unsafe</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-information-on-unsafe"><a class="header" href="#general-information-on-unsafe">General information on <code>unsafe</code></a></h1>
<h2 id="unsafe-capacities"><a class="header" href="#unsafe-capacities"><em>Unsafe</em> capacities</a></h2>
<p>Language capabilities can be extended using unsafe code. The full list of these capacities is given in the <a href="https://doc.rust-lang.org/reference/unsafety.html">Rust reference</a>. Notice the following one's.</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Modify a static mutable variable</li>
<li>Access to the fields of a <code>union</code></li>
<li>Declaring an <code>extern</code> block</li>
</ul>
<p>These capabilities may be necessary for system programming but they cause the language to lose its <a href="04_language.html#language-guarantees">security properties</a>.</p>
<h2 id="unsafe-keyword"><a class="header" href="#unsafe-keyword"><code>unsafe</code> keyword</a></h2>
<p>The <code>unsafe</code> keyword is used both for API and implementation.</p>
<h3 id="unsafe-in-api"><a class="header" href="#unsafe-in-api"><code>unsafe</code> in API</a></h3>
<p>The use of this keyword in an API <em>warns</em> the API user against the potential harmful effects of the use of the API.</p>
<ul>
<li>In a function signature, <code>unsafe</code> means that the behavior of the function may lead to <em>UB</em>s if the use of the function does not comply with its interface contract (informally described in its documentation).</li>
<li>In a trait definition, <code>unsafe</code> means that an erroneous implementation of this trait may lead to <em>UB</em>s.</li>
</ul>
<h3 id="unsafe-in-implementation"><a class="header" href="#unsafe-in-implementation"><code>unsafe</code> in implementation</a></h3>
<p>Using this keyword in an implementation (a code block) is imposed by the compiler to prevent the inadvertent use of <code>unsafe</code> functions.</p>
<h2 id="unsafe-code"><a class="header" href="#unsafe-code">Unsafe code</a></h2>
<p>The combined use of the type system and the ownership system
enforces a high-level memory safety in Rust programs. This way, the language helps prevent memory overflows, null or invalid pointer constructions, and data
races.
To perform risky actions such as system calls, type coercions, or direct
manipulations of memory pointers, the language provides the <code>unsafe</code> keyword.</p>
<blockquote>
<p><strong>Rule <a id="LANG-UNSAFE"></a>LANG-UNSAFE</strong></p>
<p>For a secured development, the <code>unsafe</code> blocks must be avoided. Afterward,
we list the only cases where <code>unsafe</code> may be used, provided that they come
with a proper justification:</p>
<ul>
<li>
<p>The Foreign Function Interface (FFI) of Rust allows for describing
functions whose implementations are written in C, using the <code>extern "C"</code>
prefix. To use such a function, the <code>unsafe</code> keyword is required. “Safe”
wrapper shall be defined to safely and seamlessly call C code.</p>
</li>
<li>
<p>For embedded device programming, registers and various other resources are
often accessed through a fixed memory address. In this case, <code>unsafe</code> blocks
are required to initialize and dereference those particular pointers in Rust.
In order to minimize the number of unsafe accesses in the code and to allow
easier identification of them by a programmer, a proper abstraction (data
structure or module) shall be provided.</p>
</li>
<li>
<p>A function can be marked unsafe globally (by prefixing its declaration with
the <code>unsafe</code> keyword) when it may exhibit unsafe behaviors based on its
arguments, that are unavoidable. For instance, this happens when a function
tries to dereference a pointer passed as an argument.</p>
</li>
</ul>
<p>With the exception of these cases, <code>#![forbid(unsafe_code)]</code> must appear in
the crate root (typically <code>main.rs</code> or <code>lib.rs</code>) to generate compilation
errors if <code>unsafe</code> is used in the code base.</p>
</blockquote>
<h2 id="general-warnings"><a class="header" href="#general-warnings">General warnings</a></h2>
<h3 id="invariants-and-wrapping-unsafe"><a class="header" href="#invariants-and-wrapping-unsafe">Invariants and wrapping <em>unsafe</em></a></h3>
<p>Exposed APIs are responsible for preserving invariants to avoid bugs in general and, when handling <code>unsafe</code> code, <em>UB</em>s in particular.</p>
<p>The following code comes from the <a href="https://doc.rust-lang.org/nomicon/working-with-unsafe.html">Rustonomicon</a>.
It could be used to implement a custom <code>Vec</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr;

pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

// Note this implementation does not correctly handle zero-sized types.
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap {
            // not important for this example
            self.reallocate();
        }
        unsafe {
            ptr::write(self.ptr.add(self.len), elem);
            self.len += 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Soundness and safety of this code rely on the fact that bytes from address <code>self.ptr</code> to <code>self.ptr + self.cap * size_of&lt;T&gt;()</code> are allocated.</p>
<p>This invariant can be broken with <em>safe</em> code. For instance</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_room(&amp;mut self) {
    // grow the capacity
    self.cap += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>This function my be necessary for internal use, but it should not be exposed in the API, or it should be marked with <code>unsafe</code> keyword, because its use can lead to <em>UB</em>.</p>
<h3 id="trust-relation-between-safe-and-unsafe"><a class="header" href="#trust-relation-between-safe-and-unsafe">Trust relation between <em>safe</em> and <em>unsafe</em></a></h3>
<h4 id="principle"><a class="header" href="#principle">Principle</a></h4>
<p>In Rust paradigm,</p>
<blockquote>
<p><code>unsafe</code>-free code cannot go wrong</p>
</blockquote>
<p>which means it cannot result in <em>UB</em>.
This property is lost when the developers use <em>unsafe</em> code, that is why they are responsible of not producing <em>UB</em> in any scenario.
Consequently, even <em>safe</em> function must be handled carefully in <em>unsafe</em> context.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>Suppose one wants to propose an API find object of a given type in the memory.
This API could ask implementing the following trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Locatable {
    /// Find object of type `Self` in the buffer `buf`.
    /// Returns the index of the first byte representing
    /// an object of type `Self`
    fn locate_instance_into(buf: &amp;[u8]) -&gt; Option&lt;usize&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>This trait can be implemented <strong>without</strong> <code>unsafe</code>.</p>
<p>For instance, <code>bool</code> type can implement this trait as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Locatable for bool {
    fn locate_instance_into(buf: &amp;[u8]) -&gt; Option&lt;usize&gt; {
        buf.iter().position(|u| *u == 0 || *u == 1)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Moreover the function searching a <code>Locatable</code> type in the memory could be the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn locate&lt;T: Locatable + Clone&gt;(start: *const u8, len: usize) -&gt; Option&lt;T&gt; {
    let buf = unsafe { from_raw_parts(start, len) };
    match T::locate_instance_into(buf) {
        Some(begin) =&gt; unsafe {
            let start_T: *const T = start.byte_add(begin).cast();
            match start_T.as_ref() {
                None =&gt; None, // if start_T is null
                Some(r) =&gt; Some(r.clone()),
            }
        },
        None =&gt; None,
    }
}
<span class="boring">}</span></code></pre></pre>
<div class="warning">
<p>This implementation is harmful for two reasons:</p>
<ul>
<li>If the <code>Locatable</code> implementation gives the wrong index, the <code>as_ref</code> function produce an <em>UB</em>.</li>
<li>If the <code>Locatable</code> implementation gives an outbound index, the subsequent buffer overflow is an <em>UB</em>.</li>
</ul>
</div>
<p>For instance, the following <code>Locatable</code> implementation is wrong <strong>but</strong> it is of the responsibility of the API maker to take it into account.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Locatable for bool {
    fn locate_instance_into(buf: &amp;[u8]) -&gt; Option&lt;usize&gt; {
        buf.iter().position(|u| *u == 0 || *u == 1).map(|n| n + 2)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The following program produces <em>UB</em>.</p>
<pre><pre class="playground"><code class="language-rust should_panic">fn main() {
    let buf = [4, 1, 99];
    let start = buf.as_ptr();
    let located_bool: Option&lt;bool&gt; = locate(start, buf.len()); // UB here!
    println!("{:?}", located_bool)
}</code></pre></pre>
<p>The error can be shown with <code>valgrind</code></p>
<pre><code>$ valgrind ./target/release/rust-unsafe
==123651== Memcheck, a memory error detector
==123651== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==123651== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info
==123651== Command: ./target/release/rust-unsafe
==123651== 
==123651== valgrind: Unrecognised instruction at address 0x10f860.
==123651==    at 0x10F860: rust_unsafe::main (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651==    by 0x10F842: std::sys::backtrace::__rust_begin_short_backtrace (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651==    by 0x10F838: std::rt::lang_start::{{closure}} (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651==    by 0x129F0F: std::rt::lang_start_internal (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651==    by 0x10F894: main (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651== Your program just tried to execute an instruction that Valgrind
==123651== did not recognise.  There are two possible reasons for this.
==123651== 1. Your program has a bug and erroneously jumped to a non-code
==123651==    location.  If you are running Memcheck and you just saw a
==123651==    warning about a bad jump, it's probably your program's fault.
==123651== 2. The instruction is legitimate but Valgrind doesn't handle it,
==123651==    i.e. it's Valgrind's fault.  If you think this is the case or
==123651==    you are not sure, please let us know and we'll try to fix it.
==123651== Either way, Valgrind will now raise a SIGILL signal which will
==123651== probably kill your program.
==123651== 
==123651== Process terminating with default action of signal 4 (SIGILL)
==123651==  Illegal opcode at address 0x10F860
==123651==    at 0x10F860: rust_unsafe::main (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651==    by 0x10F842: std::sys::backtrace::__rust_begin_short_backtrace (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651==    by 0x10F838: std::rt::lang_start::{{closure}} (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651==    by 0x129F0F: std::rt::lang_start_internal (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651==    by 0x10F894: main (in /home/toto/src/rust-unsafe/target/release/rust-unsafe)
==123651== 
==123651== HEAP SUMMARY:
==123651==     in use at exit: 0 bytes in 0 blocks
==123651==   total heap usage: 7 allocs, 7 frees, 2,072 bytes allocated
==123651== 
==123651== All heap blocks were freed -- no leaks are possible
==123651== 
==123651== For lists of detected and suppressed errors, rerun with: -s
==123651== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<h4 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h4>
<p>This example shows that developers using <code>unsafe</code> blocks
cannot assume <em>safe</em> functions/traits they
use are well implemented, and thus must prevent <em>UB</em>
in case these <em>safe</em> functions have bad behavior.</p>
<p>If they cannot protect their function against badly implemented <em>safe</em> functions/traits, they could either</p>
<ul>
<li>mark the function they <em>write</em> as <code>unsafe</code>: thus it is the user's responsibility to feed this function with correct arguments (by checking <em>unsafe</em> function documentation).</li>
<li>mark the traits they <em>use</em> as <code>unsafe</code> : thus it is user's responsibility to simplement the trait properly (again reading the trait documentation).</li>
</ul>
<h4 id="références"><a class="header" href="#références">Références</a></h4>
<ul>
<li>https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management"><a class="header" href="#memory-management">Memory management</a></h1>
<!-- ## About Rust memory safety -->
<!--
<mark>TODO</mark>: explain safe allocations/deallocations, ownership/borrowing,
and identify language constructs that may break memory safety (for instance,
unsound behaviors in older versions of the compiler).
-->
<p>In the vast majority of cases, in non-<code>unsafe</code> Rust (i.e., code that does not use <code>unsafe</code>), the compiler <strong>automatically</strong> determines when it can release the memory occupied by a value in the program.
But, as <a href="04_language.html#rust-guarantees">noted earlier</a>, this is not
a guarantee: code without <code>unsafe</code> can still lead to memory leaks. Therefore, some of the
rules presented in this chapter are not strictly related to the <code>unsafe</code> keyword. However,</p>
<blockquote>
<p>even if a function in the following is not <code>unsafe</code>,
it should only be used in Rust <em>unsafe</em>.</p>
</blockquote>
<h2 id="forget-and-memory-leaks"><a class="header" href="#forget-and-memory-leaks"><code>forget</code> and memory leaks</a></h2>
<p>While the usual way for memory to be reclaimed is for a variable to go out of
scope, Rust provides special functions to manually reclaim memory: <code>forget</code> and
<code>drop</code> of the <code>std::mem</code> module (or <code>core::mem</code>). While <code>drop</code> simply triggers
an early memory reclamation that calls associated destructors when needed,
<code>forget</code> skips any call to the destructors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pair = ('↑', 0xBADD_CAFEu32);
drop(pair); // here `forget` would be equivalent (no destructor to call)
<span class="boring">}</span></code></pre></pre>
<p>Both functions are <strong>memory safe</strong> in Rust. However, <code>forget</code> will make any
resource managed by the value unreachable and unclaimed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::mem::forget;
</span>let s = String::from("Hello");
forget(s); // Leak memory
<span class="boring">}</span></code></pre></pre>
<p>In particular, using <code>forget</code> may result in not releasing critical resources
leading to deadlocks or not erasing sensitive data from the memory. That is why,
<code>forget</code> is <strong>unsecure</strong>.</p>
<blockquote>
<p><strong>Rule <a id="MEM-FORGET"></a>MEM-FORGET</strong></p>
<p>In a secure Rust development, the <code>forget</code> function of <code>std::mem</code>
(<code>core::mem</code>) must not be used.</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Recommendation <a id="MEM-FORGET-LINT"></a>MEM-FORGET-LINT</strong></p>
<p>The lint <code>mem_forget</code> of Clippy may be used to automatically detect any use of
<code>forget</code>. To enforce the absence of <code>forget</code> in a crate, add the following
line at the top of the root file (usually <code>src/lib.rs</code> or <code>src/main.rs</code>):</p>
<pre><code class="language-rust noplaypen ignore">#![deny(clippy::mem_forget)]</code></pre>
</blockquote>
<p>The standard library includes other way to <em>forget</em> dropping values:</p>
<ul>
<li><code>Box::leak</code> to leak a resource,</li>
<li><code>Box::into_raw</code> to exploit the value in some unsafe code, notably in FFI,</li>
<li><code>ManuallyDrop</code> (in <code>std::mem</code> or <code>core::mem</code>) to enforce manual release of some value.</li>
</ul>
<p>Those alternatives may lead to the same security issue but they have the
additional benefit of making their goal obvious.</p>
<blockquote>
<p><strong>Rule <a id="MEM-LEAK"></a>MEM-LEAK</strong></p>
<p>In a secure Rust development, the code must not leak memory or resource in
particular via <code>Box::leak</code>.</p>
</blockquote>
<p><code>ManuallyDrop</code> and <code>Box::into_raw</code> shift the release responsibility from the
compiler to the developer.</p>
<blockquote>
<p><strong>Rule <a id="MEM-MANUALLYDROP"></a>MEM-MANUALLYDROP</strong></p>
<p>In a secure Rust development, any value wrapped in <code>ManuallyDrop</code> must be
unwrapped to allow for automatic release (<code>ManuallyDrop::into_inner</code>)
or manually released (unsafe <code>ManuallyDrop::drop</code>).</p>
</blockquote>
<!-- -->
<h2 id="raw-pointers"><a class="header" href="#raw-pointers">Raw pointers</a></h2>
<p>This pointers are mainly used to use C pointer. They do not have the same protections
than <em>smart pointers</em> and often have to be used in <code>unsafe</code> context. For instance, freeing
raw pointer must be done manually without Rust warranties.</p>
<blockquote>
<p><strong>Rule <a id="MEM-NORAWPOINTER"></a>MEM-NORAWPOINTER</strong></p>
<p>In a secure Rust development without <code>unsafe</code>, references and <em>smart pointers</em>
should not be converted into <em>raw pointers</em>. For instance, functions <code>into_raw</code> ou <code>into_non_null</code>
of smart pointers <code>Box</code>, <code>Rc</code>, <code>Arc</code> or <code>Weak</code> should not be used.</p>
</blockquote>
<blockquote>
<p><strong>Rule <a id="MEM-INTOFROMRAW"></a>MEM-INTOFROMRAW</strong></p>
<p>In a secure Rust development, any pointer created with a call to <code>into_raw</code>
(or <code>into_non_null</code>) from one of the following types:</p>
<ul>
<li><code>std::boxed::Box</code> (or <code>alloc::boxed::Box</code>),</li>
<li><code>std::rc::Rc</code> (or <code>alloc::rc::Rc</code>),</li>
<li><code>std::rc::Weak</code> (or <code>alloc::rc::Weak</code>),</li>
<li><code>std::sync::Arc</code> (or <code>alloc::sync::Arc</code>),</li>
<li><code>std::sync::Weak</code> (or <code>alloc::sync::Weak</code>),</li>
<li><code>std::ffi::CString</code>,</li>
<li><code>std::ffi::OsString</code>,</li>
</ul>
<p>must eventually be transformed into a value with a call to the respective
<code>from_raw</code> to allow for their reclamation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let boxed = Box::new(String::from("Crab"));
let raw_ptr = unsafe { Box::into_raw(boxed) };
let _ = unsafe { Box::from_raw(raw_ptr) }; // will be freed
<span class="boring">}</span></code></pre></pre>
</blockquote>
<p>Converse is true! That is <code>from_raw</code> should be call <strong>only</strong> on <code>into_raw</code>ed value. For instance,
<code>Rc</code> smart pointer <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.from_raw">explicitly request for this condition</a>
and, for <code>Box</code> smart pointer, conversion of C pointer into <code>Box</code> is <a href="https://doc.rust-lang.org/std/boxed/index.html#memory-layout">discouraged</a>.</p>
<blockquote>
<p><strong>Règle <a id="MEM-INTOFROMRAW"></a>MEM-INTOFROMRAW</strong>
In a secure Rust development, <code>from_raw</code> should only be called on <code>into_raw</code>ed value</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Note</strong></p>
<p>In the case of <code>Box::into_raw</code>, manual cleanup is possible but a lot more
complicated than re-boxing the raw pointer and should be avoided:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Excerpt from the standard library documentation
use std::alloc::{dealloc, Layout};
use std::ptr;

let x = Box::new(String::from("Hello"));
let p = Box::into_raw(x);
unsafe {
    ptr::drop_in_place(p);
    dealloc(p as *mut u8, Layout::new::&lt;String&gt;());
}
<span class="boring">}</span></code></pre></pre>
<p>Because the other types (<code>Rc</code> and <code>Arc</code>) are opaque and more complex, manual
cleanup is not possible.</p>
</blockquote>
<h2 id="uninitialized-memory"><a class="header" href="#uninitialized-memory">Uninitialized memory</a></h2>
<p>By default, Rust forces all values to be initialized, preventing the use of
uninitialized memory (except if using <code>std::mem::uninitialized</code> or
<code>std::mem::MaybeUninit</code>).</p>
<blockquote>
<p><strong>Rule <a id="MEM-UNINIT"></a>MEM-UNINIT</strong></p>
<p>The <code>std::mem::uninitialized</code> function (deprecated 1.38) must never be used.
Each usage of the <code>std::mem::MaybeUninit</code> type (stabilized 1.36) must be explicitly
justified when necessary.</p>
</blockquote>
<p>The use of uninitialized memory may result in two distinct security issues:</p>
<ul>
<li>drop of uninitialized memory (also a memory safety issue),</li>
<li>non-drop of initialized memory.</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p><code>std::mem::MaybeUninit</code> is an improvement over <code>std::mem::uninitialized</code>.
Indeed, it makes dropping uninitialized values a lot more difficult.
However, it does not change the second issue: the non-drop of an initialized
memory is as much likely. It is problematic, in particular when considering
the use of <code>Drop</code> to erase sensitive memory.</p>
</blockquote>
<h2 id="cyclic-reference-counted-pointers-rc-and-arc"><a class="header" href="#cyclic-reference-counted-pointers-rc-and-arc">Cyclic reference counted pointers (<code>Rc</code> and <code>Arc</code>)</a></h2>
<p>Combining <a href="https://doc.rust-lang.org/reference/interior-mutability.html">interior mutability</a>, recurcivity and reference counted pointer into type definitions is unsafe. It can produce memory leaks which can result in DDoS attack or secret leaks.</p>
<p>The following example show such a memory leak in safe Rust:</p>
<pre><pre class="playground"><code class="language-rust">use std::{cell::Cell, rc::Rc};

struct LinkedStruct {
    other: Cell&lt;Option&lt;Rc&lt;LinkedStruct&gt;&gt;&gt;,
}

fn main() {
    println!("Hello, world!");
    let a = Rc::new(LinkedStruct {
        other: Cell::new(None),
    });
    let b = Rc::new(LinkedStruct {
        other: Cell::new(None),
    });
    let aa = a.clone();
    let bb = b.clone();
    a.other.set(Some(bb));
    b.other.set(Some(aa));
}</code></pre></pre>
<p>Memory leak is shown with <code>valgrind</code>:</p>
<pre><code>$ valgrind --leak-check=full target/release/safe-rust-leak 
==153637== Memcheck, a memory error detector
==153637== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==153637== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info
==153637== Command: target/release/safe-rust-leak
==153637== 
Hello, world!
==153637== 
==153637== HEAP SUMMARY:
==153637==     in use at exit: 48 bytes in 2 blocks
==153637==   total heap usage: 10 allocs, 8 frees, 3,144 bytes allocated
==153637== 
==153637== 48 (24 direct, 24 indirect) bytes in 1 blocks are definitely lost in loss record 2 of 2
==153637==    at 0x48417B4: malloc (vg_replace_malloc.c:381)
==153637==    by 0x10F8D4: safe_rust_leak::main (in /home/toto/src/safe-rust-leak/target/release/safe-rust-leak)
==153637==    by 0x10F7E2: std::sys::backtrace::__rust_begin_short_backtrace (in /home/toto/src/safe-rust-leak/target/release/safe-rust-leak)
==153637==    by 0x10F7D8: std::rt::lang_start::{{closure}} (in /home/toto/src/safe-rust-leak/target/release/safe-rust-leak)
==153637==    by 0x12A90F: std::rt::lang_start_internal (in /home/toto/src/safe-rust-leak/target/release/safe-rust-leak)
==153637==    by 0x10FA54: main (in /home/toto/src/safe-rust-leak/target/release/safe-rust-leak)
==153637== 
==153637== LEAK SUMMARY:
==153637==    definitely lost: 24 bytes in 1 blocks
==153637==    indirectly lost: 24 bytes in 1 blocks
==153637==      possibly lost: 0 bytes in 0 blocks
==153637==    still reachable: 0 bytes in 0 blocks
==153637==         suppressed: 0 bytes in 0 blocks
==153637== 
==153637== For lists of detected and suppressed errors, rerun with: -s
==153637== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</code></pre>
<blockquote>
<p><strong>Règle <a id="MEM-MUT-REC-RC"></a>MEM-MUT-REC-RC</strong></p>
<p>Avoid recursive types whose recursivity use reference counted pointers together with interior mutability.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-function-interface-ffi"><a class="header" href="#foreign-function-interface-ffi">Foreign Function Interface (FFI)</a></h1>
<p>The Rust approach to interfacing with other languages relies on a strong
compatibility with C. However, this boundary is by its very nature <strong>unsafe</strong>
(see <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Rust Book: Unsafe Rust</a>).</p>
<p>Functions that are marked <code>extern</code> are made compatible with C code during
compilation. They may be called from C code with any parameter values.
The exact syntax is <code>extern "&lt;ABI&gt;"</code> where ABI is a calling convention and
depends on the target platform. The default one is <code>C</code> which corresponds to
a standard C calling convention on the target platform.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// export a C-compatible function
#[no_mangle]
unsafe extern "C" fn mylib_f(param: u32) -&gt; i32 {
    if param == 0xCAFEBABE { 0 } else { -1 }
}
<span class="boring">}</span></code></pre></pre>
<p>For the function <code>mylib_f</code> to be accessible with the same name, the function
must also be annotated with the <code>#[no_mangle]</code> attribute.</p>
<p>Conversely, one can call C functions from Rust if they are declared in an
<code>extern</code> block:</p>
<pre><pre class="playground"><code class="language-rust">use std::os::raw::c_int;
// import an external function from libc
extern "C" {
    fn abs(args: c_int) -&gt; c_int;
}

fn main() {
    let x = -1;
    println!("{} {}\n", x, unsafe { abs(x) });
}</code></pre></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Any foreign function imported in Rust through an <code>extern</code> block is
<strong>automatically <code>unsafe</code></strong>. That is why, any call to a foreign function
must be done from an <code>unsafe</code> context.</p>
</blockquote>
<p><code>extern</code> blocks may also contain foreign global variable declarations prefixed
with the <code>static</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust">//! A direct way to access environment variables (on Unix).
//! Should not be used! Not thread safe, have a look at `std::env`!

extern {
    // Libc global variable
    #[link_name = "environ"]
    static libc_environ: *const *const std::os::raw::c_char;
}

fn main() {
    let mut next = unsafe { libc_environ };
    while !next.is_null() &amp;&amp; !unsafe { *next }.is_null() {
        let env = unsafe { std::ffi::CStr::from_ptr(*next) }
            .to_str()
            .unwrap_or("&lt;invalid&gt;");
        println!("{}", env);
        next = unsafe { next.offset(1) };
    }
}</code></pre></pre>
<h2 id="typing"><a class="header" href="#typing">Typing</a></h2>
<p>Typing is the way Rust ensures memory safety. When interfacing with other
languages, which may not offer the same guarantee, the choice of types in the
binding is essential to maintain the memory safety.</p>
<h3 id="data-layout"><a class="header" href="#data-layout">Data layout</a></h3>
<p>Rust provides no short or long term guarantees with respect to how the data is
laid out in the memory. The only way to make data compatible with a foreign
language is through explicit use of a C-compatible data layout with the <code>repr</code>
attribute (see <a href="https://doc.rust-lang.org/reference/type-layout.html">Rust Reference: Type Layout</a>). For instance, the following Rust
types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Data {
    a: u32,
    b: u16,
    c: u64,
}
#[repr(C, packed)]
struct PackedData {
    a: u32,
    b: u16,
    c: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>are compatible with the following C types:</p>
<pre><code class="language-c">struct Data {
    uint32_t a;
    uint16_t b;
    uint64_t c;
};
__attribute__((packed))
struct PackedData {
    uint32_t a;
    uint16_t b;
    uint64_t c;
}
</code></pre>
<blockquote>
<p><strong>Rule <a id="FFI-CTYPE"></a>FFI-CTYPE</strong></p>
<p>In a secure Rust development, only C-compatible types must be used as
parameter or return type of imported or exported functions and as types of
imported or exported global variables.</p>
<p>The lone exception is types that are considered <strong>opaque</strong> on the foreign
side.</p>
</blockquote>
<p>The following types are considered C-compatible:</p>
<ul>
<li>integral or floating point primitive types,</li>
<li><code>repr(C)</code>-annotated <code>struct</code>,</li>
<li><code>repr(C)</code> or <code>repr(Int)</code>-annotated <code>enum</code> with at least one variant and only
fieldless variants (where <code>Int</code> is an integral primitive type),</li>
<li>pointers,</li>
<li>an <code>Option&lt;T&gt;</code> where <code>T</code> is either
<ul>
<li><code>core::ptr::NonNull&lt;U&gt;</code> and <code>U</code> is a <code>Sized</code> C-compatible type, then it is
compatible to a <code>*const T</code> and <code>*mut T</code> pointer;</li>
<li><code>core::num::NonZero*</code>, then is compatible to the corresponding integral
primitive type;</li>
</ul>
</li>
<li>a <code>repr(transparent)</code>-annotated <code>struct</code> with only one field, where that
field has a C-compatible type.</li>
</ul>
<p>The following types are not C-compatible:</p>
<ul>
<li>Dynamically sized types,</li>
<li>Trait objects,</li>
<li>Enums with fields,</li>
<li>Tuples (but <code>repr(C)</code> tuple structures are OK).</li>
</ul>
<p>Some types are compatibles with some caveats:</p>
<ul>
<li>Zero-sized types, which is really zero sized (which is let unspecified in C
and contradicts the C++ specification),</li>
<li><code>repr(C)</code>, <code>repr(C, Int)</code>, or <code>repr(Int)</code>-annotated enum with fields
(see <a href="https://rust-lang.github.io/rfcs/2195-really-tagged-unions.html">RFC 2195</a>).</li>
</ul>
<h3 id="type-consistency"><a class="header" href="#type-consistency">Type consistency</a></h3>
<blockquote>
<p><strong>Rule <a id="FFI-TCONS"></a>FFI-TCONS</strong></p>
<p>Types must be consistent on each side of the FFI boundary.</p>
<p>Although some details may be hidden on one side with respect to the other
(typically to make a type opaque), types on both sides must have the same size
and the same alignment requirement.</p>
</blockquote>
<p>Concerning enums with fields in particular, the corresponding types in C (or
C++) are not obvious, cf. <a href="https://rust-lang.github.io/rfcs/2195-really-tagged-unions.html">RFC 2195</a>.</p>
<p>Automated tools to generate bindings, such as <a href="https://crates.io/crates/bindgen">rust-bindgen</a> or
<a href="https://crates.io/crates/cbindgen">cbindgen</a>, may be of help in making types consistent between C and Rust.</p>
<blockquote>
<p><strong>Recommendation <a id="FFI-AUTOMATE"></a>FFI-AUTOMATE</strong></p>
<p>In a secure Rust development, automated generation tools should be used to
generate bindings when possible and to maintain them continually.</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Warning</strong></p>
<p>For binding C/C++ to Rust, <a href="https://crates.io/crates/bindgen">rust-bindgen</a> is able to automatically generate
the low-level binding. A high-level safe binding is highly recommended (see
Recommendation <a href="06_3_unsafe_ffi.html#FFI-SAFEWRAPPING">FFI-SAFEWRAPPING</a>).
Also some options of rust-bindgen may result in dangerous translations, in
particular <code>rustified_enum</code>.</p>
</blockquote>
<h3 id="platform-dependent-types"><a class="header" href="#platform-dependent-types">Platform-dependent types</a></h3>
<p>When interfacing with a foreign language, like C or C++, it is often required
to use platform-dependent types such as C's <code>int</code>, <code>long</code>, etc.</p>
<p>In addition to <code>c_void</code> in <code>std::ffi</code> (or <code>core::ffi</code>) for <code>void</code>, the standard
library offers portable type aliases in <code>std:os::raw</code> (or <code>core::os::raw</code>):</p>
<ul>
<li><code>c_char</code> for <code>char</code> (either <code>i8</code> or <code>u8</code>),</li>
<li><code>c_schar</code> for <code>signed char</code> (always <code>i8</code>),</li>
<li><code>c_uchar</code> for <code>unsigned char</code> (always <code>u8</code>),</li>
<li><code>c_short</code> for <code>short</code>,</li>
<li><code>c_ushort</code> for <code>unsigned short</code>,</li>
<li><code>c_int</code> for <code>int</code>,</li>
<li><code>c_uint</code> for <code>unsigned int</code>,</li>
<li><code>c_long</code> for <code>long</code>,</li>
<li><code>c_ulong</code> for <code>unsigned long</code>,</li>
<li><code>c_longlong</code> for <code>long long</code>,</li>
<li><code>c_ulonglong</code> for <code>unsigned long long</code>,</li>
<li><code>c_float</code> for <code>float</code> (always <code>f32</code>),</li>
<li><code>c_double</code> for <code>double</code> (always <code>f64</code>).</li>
</ul>
<p>The <a href="https://crates.io/crates/libc">libc</a> crate offers more C compatible types that cover almost exhaustively
the C standard library.</p>
<blockquote>
<p><strong>Rule <a id="FFI-PFTYPE"></a>FFI-PFTYPE</strong></p>
<p>In a secure Rust development, when interfacing with foreign code that
uses platform-dependent types, such as C's <code>int</code> and <code>long</code>, Rust code must
use portable type aliases, such as provided by the standard library or the
<a href="https://crates.io/crates/libc">libc</a> crate, rather than platform-specific types, except if
the binding is automatically generated for each platform (see Note below).</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Note</strong></p>
<p>Automatic binding generation tools (e.g. <a href="https://crates.io/crates/cbindgen">cbindgen</a>, <a href="https://crates.io/crates/bindgen">rust-bindgen</a>) are able
to ensure type consistency on a specific platform. They should be used during
the build process for each target to ensure that the generation is sound for
the specific target platform.</p>
</blockquote>
<h3 id="non-robust-types-references-function-pointers-enums"><a class="header" href="#non-robust-types-references-function-pointers-enums">Non-robust types: references, function pointers, enums</a></h3>
<p>A <em>trap representation</em> of a particular type is a representation (pattern of
bits) that respects the type's representation constraints (such as size and
alignment) but does not represent a valid value of this type and leads to
undefined behavior.</p>
<p>In simple terms, if a Rust variable is set to such an invalid value,
anything can happen from a simple program crash to arbitrary code execution.
When writing safe Rust, this cannot happen (except through a bug in the Rust
compiler). However, when writing unsafe Rust and in particular in FFI, it is
really easy.</p>
<p>In the following, <strong>non-robust types</strong> are types that have such trap
representations (at least one). A lot of Rust types are non-robust, even among
the C-compatible types:</p>
<ul>
<li><code>bool</code> (1 byte, 256 representations, only 2 valid ones),</li>
<li>references,</li>
<li>function pointers,</li>
<li>enums,</li>
<li>floats (even if almost every language have the same understanding of what is
a valid float),</li>
<li>compound types that contain a field of a non-robust type.</li>
</ul>
<p>On the other hand, integer types (<code>u*</code>/<code>i*</code>), packed compound types that contain
no non-robust fields, for instance are <em>robust types</em>.</p>
<p>Non-robust types are a difficulty when interfacing two languages. It revolves
into deciding <strong>which language of the two is responsible in asserting the
validity of boundary-crossing values</strong> and how to do it.</p>
<blockquote>
<p><strong>Rule <a id="FFI-CKNONROBUST"></a>FFI-CKNONROBUST</strong></p>
<p>In a secure Rust development, there must not be any use of <em>unchecked</em> foreign
values of non-robust types.</p>
<p>In other words, either Rust translates robust types to non-robust types
through explicit checking or the foreign side offers strong guarantees of the
validity of the value.</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Recommendation <a id="FFI-CKINRUST"></a>FFI-CKINRUST</strong></p>
<p>In a secure Rust development, the validity checks of foreign values should
be done in Rust when possible.</p>
</blockquote>
<p>Those generic rules are to be adapted to a specific foreign language or for the
associated risks. Concerning languages, C is particularly unfit to offer
guarantees about validity. However, Rust is not the only language to offer
strong guarantees. For instance, some C++ subset (without reinterpretation)
allows developers to do lot of type checking. Because Rust natively separates
the safe and unsafe segments, the recommendation is to always use Rust to check
when possible. Concerning risks, the most dangerous types are references,
function references, and enums, and are discussed below.</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>Rust's <code>bool</code> has been made equivalent to C99's <code>_Bool</code> (aliased as <code>bool</code>
in <code>&lt;stdbool.h&gt;</code>) and C++'s <code>bool</code>. However, loading a value other than 0 and
1 as a <code>_Bool</code>/<code>bool</code> is an undefined behavior <em>on both sides</em>.
Safe Rust ensures that. Standard-compliant C and C++ compilers ensure that no
value but 0 and 1 can be <em>stored</em> in a <code>_Bool</code>/<code>bool</code> value but cannot
guarantee the absence of an <em>incorrect reinterpretation</em> (e.g., union types,
pointer cast). To detect such a bad reinterpretation, sanitizers such as
LLVM's <code>-fsanitize=bool</code> may be used.</p>
</blockquote>
<h4 id="references-and-pointers"><a class="header" href="#references-and-pointers">References and pointers</a></h4>
<p>Although they are allowed by the Rust compiler, the use of Rust references in
FFI may break Rust's memory safety. Because their “unsafety” is more explicit,
pointers are preferred over Rust references when binding to another language.</p>
<p>On the one hand, reference types are very non-robust: they allow only pointers
to valid memory objects. Any deviation leads to undefined behavior.</p>
<p>When binding to and from C, the problem is particularly severe because C has
no references (in the sense of valid pointers) and the compiler does not offer
any safety guarantee.</p>
<p>When binding with C++, Rust references may be bound to C++ references in
practice even though the actual ABI of an <code>extern "C"</code> function in C++ with
references is “implementation-defined”. Also, the C++ code should be checked
against pointer/reference confusion.</p>
<p>Rust references may be used reasonably with other C-compatible languages
including C variants allowing for non-null type checking, e.g. Microsoft SAL
annotated code.</p>
<p>On the other hand, Rust's <em>pointer types</em> may also lead to undefined behaviors
but are more verifiable, mostly against <code>std/core::ptr::null()</code> (C's <code>(void*)0</code>)
but also in some context against a known valid memory range (particularly in
embedded systems or kernel-level programming). Another advantage of using Rust
pointers in FFI is that any load of the pointed value is clearly marked inside
an <code>unsafe</code> block or function.</p>
<blockquote>
<p><strong>Recommendation <a id="FFI-NOREF"></a>FFI-NOREF</strong></p>
<p>In a secure Rust development, the Rust code should not use references types
but pointer types.</p>
<p>Exceptions include:</p>
<ul>
<li>Rust references that are opaque in the foreign language and only manipulated
from the Rust side,</li>
<li><code>Option</code>-wrapped references (see Note below),</li>
<li>references bound to foreign safe references, e.g. from some augmented C
variants or from C++ compiled in an environment where <code>extern "C"</code>
references are encoded as pointers.</li>
</ul>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Rule <a id="FFI-CKREF"></a>FFI-CKREF</strong></p>
<p>In a secure Rust development, every foreign references that is transmitted to
Rust through FFI must be <strong>checked on the foreign side</strong> either automatically
(for instance, by a compiler) or manually.</p>
<p>Exceptions include Rust references in an opaque wrapping that is created
and manipulated only from the Rust side and <code>Option</code>-wrapped references
(see Note below).</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Rule <a id="FFI-CKPTR"></a>FFI-CKPTR</strong></p>
<p>In a secure Rust development, any Rust code that dereferences a foreign
pointer must check their validity beforehand.
In particular, pointers must be checked to be non-null before any use.</p>
<p>Stronger approaches are advisable when possible. They includes checking
pointers against known valid memory range or tagging (or signing) pointers
(particularly applicable if the pointed value is only manipulated from Rust).</p>
</blockquote>
<p>The following code a simple example of foreign pointer use in an exported Rust
function:</p>
<pre><code class="language-rust noplaypen">/// Add in place
#[no_mangle]
pub unsafe extern fn add_in_place(a: *mut u32, b: u32) {
    // checks for nullity of `a`
    // and takes a mutable reference on it if it's non-null
    if let Some(a) = a.as_mut() {
        *a += b
    }
}</code></pre>
<p>Note that the methods <code>as_ref</code> and <code>as_mut</code> (for mutable pointers) allows easy
access to a reference while ensuring a null check in a very <em>Rusty</em> way.
On the other side in C, it can be used as follows:</p>
<pre><code class="language-c">#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

//! Add in place
void add_in_place(uint32_t *a, uint32_t b);

int main() {
    uint32_t x = 25;
    add_in_place(&amp;x, 17);
    printf("%" PRIu32 " == 42", x);
    return 0;
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p><code>Option&lt;&amp;T&gt;</code> and <code>Option&lt;&amp;mut T&gt;</code> for any <code>T: Sized</code> are allowable in FFI
instead of pointers with explicit nullity checks. Due to the Rust guaranteed
“nullable pointer optimization”, a nullable pointer is acceptable on the C
side. The C <code>NULL</code> is understood as <code>None</code> in Rust while a non-null
pointer is encapsulated in <code>Some</code>. While quite ergonomic, this feature does
not allow stronger validations such as memory range checking.</p>
</blockquote>
<h4 id="function-pointers"><a class="header" href="#function-pointers">Function pointers</a></h4>
<p>Function pointers that cross FFI boundaries may ultimately lead to arbitrary code
execution and represents a real security risks.</p>
<blockquote>
<p><strong>Rule <a id="FFI-MARKEDFUNPTR"></a>FFI-MARKEDFUNPTR</strong></p>
<p>In a secure Rust development, any function pointer types at the FFI boundary
must be marked <code>extern</code> (possibly with the specific ABI) and <code>unsafe</code>.</p>
</blockquote>
<p>Function pointers in Rust are a lot more similar to references than they are
to normal pointers. In particular, the validity of function pointers cannot be
checked directly on the Rust side. However, Rust offers two alternative
possibilities:</p>
<ul>
<li>
<p>use <code>Option</code>-wrapped function pointer and check against <code>null</code>:</p>
<pre><code class="language-rust noplaypen">#[no_mangle]
pub unsafe extern "C" fn repeat(start: u32, n: u32, f: Option&lt;unsafe extern "C" fn(u32) -&gt; u32&gt;) -&gt; u32 {
    if let Some(f) = f {
        let mut value = start;
        for _ in 0..n {
            value = f(value);
        }
        value
    } else {
        start
    }
}</code></pre>
<p>On the C side:</p>
<pre><code class="language-c">uint32_t repeat(uint32_t start, uint32_t n, uint32_t (*f)(uint32_t));
</code></pre>
</li>
<li>
<p>use raw pointers with an <code>unsafe</code> transmutation to the function pointer type,
allowing more powerful checks at the cost of ergonomics.</p>
</li>
</ul>
<blockquote>
<p><strong>Rule <a id="FFI-CKFUNPTR"></a>FFI-CKFUNPTR</strong></p>
<p>In a secure Rust development, any foreign function pointer must be checked at
the FFI boundary.</p>
</blockquote>
<p>When binding with C or even C++, one cannot guarantee easily the validity of the
function pointer. C++ functors are not C-compatible.</p>
<h4 id="enums"><a class="header" href="#enums">Enums</a></h4>
<p>Usually the possible bit patterns of valid <code>enum</code> values are really small with
respect to the number of possible bit patterns of the same size. Mishandling an
<code>enum</code> value provided by a foreign code may lead to type confusion and have
severe consequences on software security. Unfortunately, checking an <code>enum</code>
value at the FFI boundary is not simple on both sides.</p>
<p>On the Rust side, it consists to actually use an integer type in the <code>extern</code>
block declaration, a <em>robust</em> type, and then to perform a checked conversion
to the enum type.</p>
<p>On the foreign side, it is possible only if the other language allows for
stricter checks than plain C. <code>enum class</code> in C++ are for instance allowable.
Note however that as for reference the actual <code>extern "C"</code> ABI of
<code>enum class</code> is implementation defined and should be verified for each
environment.</p>
<blockquote>
<p><strong>Recommendation <a id="FFI-NOENUM"></a>FFI-NOENUM</strong></p>
<p>In a secure Rust development, when interfacing with a foreign language,
the Rust code should not accept incoming values of any Rust <code>enum</code> type.</p>
<p>Exceptions include Rust <code>enum</code> types that are:</p>
<ul>
<li>opaque in the foreign language and only manipulated from the
Rust side,</li>
<li>bound to safe enums in the foreign language, e.g. <code>enum class</code> types in C++.</li>
</ul>
</blockquote>
<p>Concerning fieldless enums, crates like [<code>num_derive</code>] or [<code>num_enum</code>] allows
developer to easily provide safe conversion from integer to enumeration and may
be use to safely convert an integer (provided from a C <code>enum</code>) into a Rust enum.</p>
<h3 id="opaque-types"><a class="header" href="#opaque-types">Opaque types</a></h3>
<p>Opacifying types is a good way to increase modularity in software development.
When doing multilingual development, it is something very common.</p>
<blockquote>
<p><strong>Recommendation <a id="FFI-R-OPAQUE"></a>FFI-R-OPAQUE</strong></p>
<p>In a secure Rust development, when binding foreign opaque types, one should
use pointers to dedicated opaque types rather than <code>c_void</code> pointers.</p>
</blockquote>
<p>Currently the recommended way to make a foreign opaque type is like so:</p>
<pre><code class="language-rust unsafe noplaypen">#[repr(C)]
pub struct Foo {_private: [u8; 0]}
extern "C" {
    fn foo(arg: *mut Foo);
}</code></pre>
<p>The not yet implemented <a href="https://rust-lang.github.io/rfcs/1861-extern-types.html">RFC 1861</a> proposes to facilitate the coding by allowing
to declare opaque types in <code>extern</code> blocks.</p>
<blockquote>
<p><strong>Recommendation <a id="FFI-C-OPAQUE"></a>FFI-C-OPAQUE</strong></p>
<p>In a secure Rust development, when interfacing with C or C++, Rust types that
are to be considered opaque in C/C++ should be translated as incomplete
<code>struct</code> type (i,e., declared without definition) and be provided with
a dedicated constructor and destructor.</p>
</blockquote>
<p>Example of opaque Rust type:</p>
<pre><code class="language-rust unsafe noplaypen"><span class="boring">use std::panic::catch_unwind;
</span><span class="boring">
</span>struct Opaque {
    // (...) details to be hidden
}

#[no_mangle]
pub unsafe extern "C" fn new_opaque() -&gt; *mut Opaque {
    catch_unwind(|| // Catch panics, see below
        Box::into_raw(Box::new(Opaque {
            // (...) actual construction
        }))
    ).unwrap_or(std::ptr::null_mut())
}

#[no_mangle]
pub unsafe extern "C" fn destroy_opaque(o: *mut Opaque) {
    catch_unwind(||
        if !o.is_null() {
            drop(Box::from_raw(o))
        }
    ); // Only needed if Opaque or one of its subfield is Drop
}</code></pre>
<h2 id="memory-and-resource-management"><a class="header" href="#memory-and-resource-management">Memory and resource management</a></h2>
<p>Programming languages handle memory in various ways. As a result, it is
important to known when transmitting data between Rust and another language
which language is responsible for reclaiming the memory space for this data.
The same is true for other kind of resources such as sockets or files.</p>
<p>Rust tracks variable ownership and lifetime to determine at compilation time if
and when memory should be deallocated. Thanks to the <code>Drop</code> trait, one can
exploit this system to reclaim other kind of resources such as file or network
access. <em>Moving</em> some piece of data from Rust to a foreign language means also
abandoning the possible reclamations associated with it.</p>
<blockquote>
<p><strong>Rule <a id="FFI-MEM-NODROP"></a>FFI-MEM-NODROP</strong></p>
<p>In a secure Rust development, Rust code must not implement <code>Drop</code> for any
types that are directly transmitted to foreign code  (i.e. not through a
pointer or reference).</p>
</blockquote>
<p>In fact, it is advisable to only use <code>Copy</code> types. Note that <code>*const T</code> is
<code>Copy</code> even if T is not.</p>
<p>However if not reclaiming memory and resources is bad, using reclaimed memory or
reclaiming twice some resources is worst from a security point of view. In order
to correctly release a resource only once, one must known which language is
responsible for allocating and deallocating memory.</p>
<blockquote>
<p><strong>Rule <a id="FFI-MEM-OWNER"></a>FFI-MEM-OWNER</strong></p>
<p>In a secure Rust development, when data of some type passes without copy
through a FFI boundary, one must ensure that:</p>
<ul>
<li>A single language is responsible for both allocation and deallocation of
data.</li>
<li>The other language must not allocate or free the data directly but use
dedicated foreign functions provided by the chosen language.</li>
</ul>
</blockquote>
<p>Ownership is not enough. It remains to ensure the correct lifetime, mostly that
no use occurs after reclamation. It is a lot more challenging. When the other
language is responsible for the memory, the best way is to provide a safe
wrapper around the foreign type:</p>
<blockquote>
<p><strong>Recommendation <a id="FFI-MEM-WRAPPING"></a>FFI-MEM-WRAPPING</strong></p>
<p>In a secure Rust development, any non-sensitive foreign piece of data that are
allocated and deallocated in the foreign language should be encapsulated in a
<code>Drop</code> type in such a way as to provide automatic deallocation in Rust,
through an automatic call to the foreing language deallocation routine.</p>
</blockquote>
<p>A simple example of Rust wrapping over an external opaque type:</p>
<pre><code class="language-rust ignore noplaypen"><span class="boring">use std::ops::Drop;
</span><span class="boring">
</span>/// Private “raw” opaque foreign type Foo
#[repr(C)]
struct RawFoo {
    _private: [u8; 0],
}

/// Private “raw” C API
extern "C" {
    fn foo_create() -&gt; *mut RawFoo;
    fn foo_do_something(this: *const RawFoo);
    fn foo_destroy(this: *mut RawFoo);
}

/// Foo
pub struct Foo(*mut RawFoo);
<span class="boring">
</span>impl Foo {
    /// Create a Foo
    pub fn new() -&gt; Option&lt;Foo&gt; {
        let raw_ptr = unsafe { foo_create() };
        if raw_ptr.is_null() {
            None
        } else {
            Some(Foo(raw_ptr))
        }
    }
<span class="boring">
</span>    /// Do something on a Foo
    pub fn do_something(&amp;self) {
        unsafe { foo_do_something(self.0) }
    }
}
<span class="boring">
</span>impl Drop for Foo {
    fn drop(&amp;mut self) {
        if !self.0.is_null() {
            unsafe { foo_destroy(self.0) }
        }
    }
}

<span class="boring">fn main() {
</span><span class="boring">    let foo = Foo::new().expect("cannot create Foo");
</span><span class="boring">    foo.do_something();
</span><span class="boring">}</span></code></pre>
<blockquote>
<p><strong>Warning</strong></p>
<p>Because panics may lead to not running the <code>Drop::drop</code> method this solution
is not sufficient for sensitive deallocation (such as wiping sensitive data)
except if the code is guaranteed to never panic.</p>
<p>For wiping sensitive data case, one could address the issue with a dedicated
panic handler.</p>
</blockquote>
<p>When the foreign language is the one exploiting Rust allocated resources, it is
a lot more difficult to offer any guarantee.</p>
<p>In C for instance there is no easy way to check that the appropriate destructor
is checked. A possible approach is to exploit callbacks to ensure that the
reclamation is done.</p>
<p>The following Rust code is a <strong>thread-unsafe</strong> example of a C-compatible API
that provide callback to ensure safe resource
reclamation:</p>
<pre><code class="language-rust noplaypen"><span class="boring">use std::ops::Drop;
</span><span class="boring">
</span>pub struct XtraResource {/*fields */}

impl XtraResource {
    pub fn new() -&gt; Self {
        XtraResource { /* ... */}
    }
    pub fn dosthg(&amp;mut self) {
        /*...*/
    }
}

impl Drop for XtraResource {
    fn drop(&amp;mut self) {
        println!("xtra drop");
    }
}

pub mod c_api {
    use super::XtraResource;
    use std::panic::catch_unwind;

    const INVALID_TAG: u32 = 0;
    const VALID_TAG: u32 = 0xDEAD_BEEF;
    const ERR_TAG: u32 = 0xDEAF_CAFE;

    static mut COUNTER: u32 = 0;

    pub struct CXtraResource {
        tag: u32, // to detect accidental reuse
        id: u32,
        inner: XtraResource,
    }

    #[no_mangle]
    pub unsafe extern "C" fn xtra_with(cb: extern "C" fn(*mut CXtraResource) -&gt; ()) {
        let inner = if let Ok(res) = catch_unwind(XtraResource::new) {
            res
        } else {
<span class="boring">            println!("cannot allocate resource");
</span>            return;
        };
        let id = COUNTER;
        let tag = VALID_TAG;

        COUNTER = COUNTER.wrapping_add(1);
        // Use heap memory and do not provide pointer to stack to C code!
        let mut boxed = Box::new(CXtraResource { tag, id, inner });

<span class="boring">        println!("running the callback on {:p}", boxed.as_ref());
</span>        cb(boxed.as_mut() as *mut CXtraResource);

        if boxed.id == id &amp;&amp; (boxed.tag == VALID_TAG || boxed.tag == ERR_TAG) {
<span class="boring">            println!("freeing {:p}", boxed.as_ref());
</span>            boxed.tag = INVALID_TAG; // prevent accidental reuse
                                 // implicit boxed drop
        } else {
<span class="boring">            println!("forgetting {:p}", boxed.as_ref());
</span>            // (...) error handling (should be fatal)
            boxed.tag = INVALID_TAG; // prevent reuse
            std::mem::forget(boxed); // boxed is corrupted it should not be
        }
    }

    #[no_mangle]
    pub unsafe extern "C" fn xtra_dosthg(cxtra: *mut CXtraResource) {
        let do_it = || {
            if let Some(cxtra) = cxtra.as_mut() {
                if cxtra.tag == VALID_TAG {
<span class="boring">                    println!("doing something with {:p}", cxtra);
</span>                    cxtra.inner.dosthg();
                    return;
                }
            }
            println!("doing nothing with {:p}", cxtra);
        };
        if catch_unwind(do_it).is_err() {
            if let Some(cxtra) = cxtra.as_mut() {
<span class="boring">                println!("panicking with {:p}", cxtra);
</span>                cxtra.tag = ERR_TAG;
            }
        };
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>A compatible C call:</p>
<pre><code class="language-c">struct XtraResource;
void xtra_with(void (*cb)(XtraResource* xtra));
void xtra_sthg(XtraResource* xtra);

void cb(XtraResource* xtra) {
    // ()...) do anything with the proposed C API for XtraResource
    xtra_sthg(xtra);
}

int main() {
    xtra_with(cb);
}
</code></pre>
<h2 id="panics-with-foreign-code"><a class="header" href="#panics-with-foreign-code">Panics with foreign code</a></h2>
<p>When calling Rust code from another language (e.g. C), the Rust code must
be careful to never panic.
Stack unwinding from Rust code into foreign code results in <strong>undefined behavior</strong>.</p>
<blockquote>
<p><strong>Rule <a id="FFI-NOPANIC"></a>FFI-NOPANIC</strong></p>
<p>Rust code called from FFI must either ensure the function cannot panic, or use
a panic handling mechanism (such as <code>std::panic::catch_unwind</code>,
<code>std::panic::set_hook</code>, <code>#[panic_handler]</code>) to ensure the rust code will not
abort or return in an unstable state.</p>
</blockquote>
<p>Note that <code>catch_unwind</code> will only catch unwinding panics, not those that abort
the process.</p>
<pre><code class="language-rust unsafe noplaypen ignore">use std::panic::catch_unwind;
<span class="boring">use rand;
</span>
fn may_panic() {
    if rand::random() {
        panic!("panic happens");
    }
}

#[no_mangle]
pub unsafe extern "C" fn no_panic() -&gt; i32 {
    let result = catch_unwind(may_panic);
    match result {
        Ok(_) =&gt; 0,
        Err(_) =&gt; -1,
    }
}</code></pre>
<h3 id="no_std"><a class="header" href="#no_std"><code>no_std</code></a></h3>
<p>In the case of <code>#![no_std]</code> program, a panic handler (<code>#[panic_handler]</code>) must
be defined to ensure security. The panic handler should be written with great
care in order to ensure both the safety and security of the program.</p>
<p>Another approach is to simply ensure that there is no use of <code>panic!</code> with the
<a href="https://crates.io/crates/panic-never"><code>panic-never</code></a> crate. Like <a href="https://crates.io/crates/no-panic"><code>no-panic</code></a>, <a href="https://crates.io/crates/panic-never"><code>panic-never</code></a> relies on a linking
trick: the linker fails if a non-trivially-dead branch leads to <code>panic!</code>.</p>
<h2 id="binding-a-foreign-library-in-rust"><a class="header" href="#binding-a-foreign-library-in-rust">Binding a foreign library in Rust</a></h2>
<blockquote>
<p><strong>Recommendation <a id="FFI-SAFEWRAPPING"></a>FFI-SAFEWRAPPING</strong></p>
<p>Interfacing a library written in another language in Rust should be done in
two parts:</p>
<ul>
<li>a low-level, possibly <em>hidden</em>, module that closely translates the original
C API into <code>extern</code> blocks,</li>
<li>a safe wrapping module that ensures memory safety and security invariants at
the Rust level.</li>
</ul>
<p>If the low-level API is exposed to the world, it should be done in a dedicated
crate with a name of the form <code>*-sys</code>.</p>
</blockquote>
<p>The crate <a href="https://crates.io/crates/bindgen">rust-bindgen</a> may be used to automatically generate the low-level
part of the binding from C header files.</p>
<!--
<mark>TODO</mark> example
-->
<h2 id="binding-a-rust-library-in-another-language"><a class="header" href="#binding-a-rust-library-in-another-language">Binding a Rust library in another language</a></h2>
<blockquote>
<p><strong>Recommendation <a id="FFI-CAPI"></a>FFI-CAPI</strong></p>
<p>In a secure Rust development, exposing a Rust library to a foreign language
should only be done through a <strong>dedicated C-compatible API</strong>.</p>
</blockquote>
<p>The crate <a href="https://crates.io/crates/cbindgen">cbindgen</a> may be used to automatically generate C or C++ bindings to
the Rust C-compatible API of a Rust library.</p>
<h3 id="minimal-example-of-a-c-exported-rust-library"><a class="header" href="#minimal-example-of-a-c-exported-rust-library">Minimal example of a C-exported Rust library</a></h3>
<p><code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplaypen">/// Opaque counter
pub struct Counter(u32);

impl Counter {
    /// Create a counter (initially at 0)
    fn new() -&gt; Self {
        Self(0)
    }
    /// Get the current value of the counter
    fn get(&amp;self) -&gt; u32 {
        self.0
    }
    /// Increment the value of the counter if there's no overflow
    fn incr(&amp;mut self) -&gt; bool {
        if let Some(n) = self.0.checked_add(1) {
            self.0 = n;
            true
        } else {
            false
        }
    }
}

// C-compatible API

#[no_mangle]
pub unsafe extern "C" fn counter_create() -&gt; *mut Counter {
    Box::into_raw(Box::new(Counter::new()))
}

#[no_mangle]
pub unsafe extern "C" fn counter_incr(counter: *mut Counter) -&gt; std::os::raw::c_int {
    if let Some(counter) = counter.as_mut() {
        if counter.incr() {
            0
        } else {
            -1
        }
    } else {
        -2
    }
}

#[no_mangle]
pub unsafe extern "C" fn counter_get(counter: *const Counter) -&gt; u32 {
    if let Some(counter) = counter.as_ref() {
        return counter.get();
    }
    return 0;
}

#[no_mangle]
pub unsafe extern fn counter_destroy(counter: *mut Counter) -&gt; std::os::raw::c_int {
    if !counter.is_null() {
        let _ = Box::from_raw(counter); // get box and drop
        return 0;
    }
    return -1;
}</code></pre>
<p>Using <a href="https://crates.io/crates/cbindgen">cbindgen</a> (<code>[cbindgen] -l c &gt; counter.h</code>), one can generate a consistent
C header, <code>counter.h</code>:</p>
<pre><code class="language-c">#include &lt;stdarg.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Counter Counter;

Counter *counter_create(void);

int counter_destroy(Counter *counter);

uint32_t counter_get(const Counter *counter);

int counter_incr(Counter *counter);
</code></pre>
<p><code>counter_main.c</code>:</p>
<pre><code class="language-c">#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;inttypes.h&gt;

#include "counter.h"

int main(int argc, const char** argv) {
    if (argc &lt; 2) {
        return -1;
    }
    size_t n = (size_t)strtoull(argv[1], NULL, 10);

    Counter* c = counter_create();
    for (size_t i=0; i &lt; n; i++) {
        if (counter_incr(c) != 0) {
            printf("overflow\n");
            counter_destroy(c);
            return -1;
        }
    }

    printf("%" PRIu32 "\n", counter_get(c));
    counter_destroy(c);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-licence-20licence-ouverte-20"><a class="header" href="#open-licence-20licence-ouverte-20">OPEN LICENCE 2.0/LICENCE OUVERTE 2.0</a></h1>
<h2 id="reuse-of-the-information-covered-by-this-licence"><a class="header" href="#reuse-of-the-information-covered-by-this-licence">“Reuse” of the “Information” covered by this licence</a></h2>
<p>The “Grantor” grants the “Reuser” the free, non-exclusive right to “Reuse” the “Information” subject of this licence, for commercial or non-commercial purposes, worldwide and for an unlimited period, in accordance with the conditions stated below.</p>
<p><strong>The “Reuser” is free to reuse the “Information”:</strong></p>
<ul>
<li>To reproduce it, copy it.</li>
<li>To adapt, modify, retrieve and transform it in order to create “derived information”, products and services.</li>
<li>To share, disseminate, redistribute, publish and transmit it.</li>
<li>To exploit it for commercial purposes, e.g., by combining it with other information, or by including it in his/her own product or application.</li>
</ul>
<p><strong>Subject to:</strong></p>
<ul>
<li>An acknowledgement of the authorship of the “Information”: its source (at least, the name of the “Grantor”) and the date of the most recent update of the reused “Information”. Specifically, the “Reuser” may satisfy this condition by pointing, via a hypertext link, to the source of “the Information” and so supplying an actual acknowledgement of its authorship.</li>
</ul>
<p><strong>For example:</strong></p>
<blockquote>
<p>“Ministry of xxx—Original data downloaded from <code>http://www.data.gouv.fr/fr/datasets/xxx/</code>, updated on 14 February 2017”.</p>
</blockquote>
<p>This acknowledgement of authorship does not confer any official status on the “Reuse” of the “Information”, and must not suggest any sort of recognition or endorsement on the part of the “Grantor”, or any other public entity, of the “Reuser” or of their “Reuse”.</p>
<h2 id="personal-data"><a class="header" href="#personal-data">Personal data</a></h2>
<p>The “Information” made available may contain “Personal data” that may be subject to “Reuse”. If this is the case, the “Grantor” informs the “Reuser” about its existence. The “Information” may be freely reused, within the rights granted by this licence, subject to compliance with the legal framework relating to personal data protection.</p>
<h2 id="intellectual-property-rights"><a class="header" href="#intellectual-property-rights">Intellectual property rights</a></h2>
<p>It is guaranteed to The “Reuser” that potential “Intellectual property rights” held by third parties or by the “Grantor” on “Information” do not interfere with the rights granted by this licence.</p>
<p>When the “Grantor” holds transferable “Intellectual property rights” on the “Information”, he/she assigns these to the “Reuser” on a non-exclusive basis, free of charge, worldwide, for the entire duration of the “Intellectual property rights”, and the “Reuser” is free to use the “Information” for any purpose that complies with the rights and conditions defined in this licence.</p>
<h2 id="liability"><a class="header" href="#liability">Liability</a></h2>
<p>The “Information” is made available as it is produced or received by the “Grantor”, without any other express or tacit guarantee than those set out in this licence. The “Grantor” does not guarantee the absence of errors or inaccuracies in the “Information”, nor a continuous supply of the “Information”. He/she cannot be held responsible for any loss, prejudice or damage of any kind caused to third parties as a result of the “Reuse”.</p>
<p>The “Reuser” is solely responsible for the “Reuse” of the “Information”. This “Reuse” must not mislead third parties as to the contents of the “Information”, its source or its date of update.</p>
<h2 id="applicable-legislation"><a class="header" href="#applicable-legislation">Applicable legislation</a></h2>
<p>This licence is governed by French law.</p>
<h3 id="compatibility-of-this-licence"><a class="header" href="#compatibility-of-this-licence">Compatibility of this licence</a></h3>
<p>This licence has been designed to be compatible with any free licence that at least requires an acknowledgement of authorship, and specifically with the previous version of this licence as well as with the following licences: United Kingdom’s “Open Government Licence” (OGL), Creative Commons’ “Creative Commons Attribution” (CC-BY) and Open Knowledge Foundation’s “Open Data Commons Attribution” (ODC-BY).</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>Within the meaning of this licence, are to be considered as :</p>
<ul>
<li>The “Grantor”: any person granting the right to “Reuse” “Information” under the rights and conditions set out in this licence.</li>
<li>The “Information”:
<ul>
<li>any public information contained in documents disclosed or published by any administration referred to in the first paragraph of Article L. 300-2 of the code des relations entre le public et l’administration (CRPA),</li>
<li>any information made available by any person under the terms and conditions of this licence.</li>
</ul>
</li>
<li>The “Reuse”: the use of the “Information” for other purposes than those for which it was produced or received.</li>
<li>The“Reuser”: any person reusing the “Information” in accordance with the conditions of this licence.</li>
<li>“Personal data”: any information relating to an identified or identifiable natural person who may be identified directly or indirectly. Its “Reuse” is conditional on the respect of the existing legal framework.</li>
<li>“Derived information”: any new data or information created directly from the “Information” or from a combination of the “Information” and other data or information not subject to this licence.</li>
<li>“Intellectual property rights”: all rights identified as such under the code de la propriété intellectuelle (including copyright, rights related to copyright, sui generis rights of database producers, etc.).</li>
</ul>
<h2 id="about-this-licence"><a class="header" href="#about-this-licence">About this licence</a></h2>
<p>This licence is intended to be used by administrations for the reuse of their public information. It can also be used by any individual wishing to supply “Information” under the conditions defined in this licence.</p>
<p>France has a comprehensive legal framework aiming at the spontaneous dissemination by the administrations of their public information in order to ensure the widest possible reuse of this information.</p>
<p>The right to “Reuse” the administrations’ “Information” is governed by the code des relations entre le public et l’administration  (CRPA).</p>
<p>This licence facilitates the unrestricted and free of charge reuse of public information and is one of the licences which can be used by the administration pursuant to the decree issued under article L. 323-2 of the CRPA.</p>
<p>Under the Prime Minister’s authority, the Etalab mission is mandated to open up the maximum amount of data held by State administrations and public institutions. Etalab has drawn up the Open Licence to facilitate the unrestricted and free of charge reuse of public information, as defined by article L. 321-1 of the CRPA.</p>
<p>This licence is version 2.0 of the Open Licence.</p>
<p>Etalab reserves the right to propose new versions of the Open Licence. Nevertheless, “Reusers” may continue to reuse information obtained under this licence should they so wish.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist"><a class="header" href="#checklist">Checklist</a></h1>
<ul>
<li>
<p>Development environment:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Use a stable compilation toolchain (<a href="02_devenv.html#DENV-STABLE">DENV-STABLE</a>)</li>
<li><input disabled="" type="checkbox"/>
Keep default values for critical variables in cargo profiles (<a href="02_devenv.html#DENV-CARGO-OPTS">DENV-CARGO-OPTS</a>)</li>
<li><input disabled="" type="checkbox"/>
Keep default values for compiler environment variables when running cargo (<a href="02_devenv.html#DENV-CARGO-ENVVARS">DENV-CARGO-ENVVARS</a>)</li>
<li><input disabled="" type="checkbox"/>
Use linter regularly (<a href="02_devenv.html#DENV-LINTER">DENV-LINTER</a>)</li>
<li><input disabled="" type="checkbox"/>
Use Rust formatter (rustfmt) (<a href="02_devenv.html#DENV-FORMAT">DENV-FORMAT</a>)</li>
<li><input disabled="" type="checkbox"/>
Manually check automatic fixes (<a href="02_devenv.html#DENV-AUTOFIX">DENV-AUTOFIX</a>)</li>
</ul>
</li>
<li>
<p>Libraries:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Check for outdated dependencies versions (cargo-outdated) (<a href="03_libraries.html#LIBS-OUTDATED">LIBS-OUTDATED</a>)</li>
<li><input disabled="" type="checkbox"/>
Check for security vulnerabilities report on dependencies (cargo-audit) (<a href="03_libraries.html#LIBS-AUDIT">LIBS-AUDIT</a>)</li>
<li><input disabled="" type="checkbox"/>
Check for unsafe code in dependencies (<a href="03_libraries.html#LIBS-UNSAFE">LIBS-UNSAFE</a>)</li>
</ul>
</li>
<li>
<p>Language generalities:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Respect naming conventions (<a href="04_language.html#LANG-NAMING">LANG-NAMING</a>)</li>
<li><input disabled="" type="checkbox"/>
Use appropriate arithmetic operations regarding potential overflows (<a href="04_language.html#LANG-ARITH">LANG-ARITH</a>)</li>
<li><input disabled="" type="checkbox"/>
Implement custom <code>Error</code> type, wrapping all possible errors (<a href="04_language.html#LANG-ERRWRAP">LANG-ERRWRAP</a>)</li>
<li><input disabled="" type="checkbox"/>
Use the <code>?</code> operator and do not use the <code>try!</code> macro (<a href="04_language.html#LANG-ERRDO">LANG-ERRDO</a>)</li>
<li><input disabled="" type="checkbox"/>
Don't use functions that can cause <code>panic!</code> (<a href="04_language.html#LANG-NOPANIC">LANG-NOPANIC</a>)</li>
<li><input disabled="" type="checkbox"/>
Test properly array indexing or use the <code>get</code> method (<a href="04_language.html#LANG-ARRINDEXING">LANG-ARRINDEXING</a>)</li>
<li><input disabled="" type="checkbox"/>
Handle correctly <code>panic!</code> in FFI (<a href="04_language.html#LANG-FFIPANIC">LANG-FFIPANIC</a>)</li>
</ul>
</li>
<li>
<p>Type system:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Justify <code>Drop</code> implementation (<a href="05_typesystem.html#LANG-DROP">LANG-DROP</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not panic in <code>Drop</code> implementation (<a href="05_typesystem.html#LANG-DROP-NO-PANIC">LANG-DROP-NO-PANIC</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not allow cycles of reference-counted <code>Drop</code> (<a href="05_typesystem.html#LANG-DROP-NO-CYCLE">LANG-DROP-NO-CYCLE</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not rely only on <code>Drop</code> to ensure security (<a href="05_typesystem.html#LANG-DROP-SEC">LANG-DROP-SEC</a>)</li>
<li><input disabled="" type="checkbox"/>
Justify <code>Send</code> and <code>Sync</code> implementation (<a href="05_typesystem.html#LANG-SYNC-TRAITS">LANG-SYNC-TRAITS</a>)</li>
<li><input disabled="" type="checkbox"/>
Respect the invariants of standard comparison traits (<a href="05_typesystem.html#LANG-CMP-INV">LANG-CMP-INV</a>)</li>
<li><input disabled="" type="checkbox"/>
Use the default method implementation of standard comparison traits (<a href="05_typesystem.html#LANG-CMP-DEFAULTS">LANG-CMP-DEFAULTS</a>)</li>
<li><input disabled="" type="checkbox"/>
Derive comparison traits when possible (<a href="05_typesystem.html#LANG-CMP-DERIVE">LANG-CMP-DERIVE</a>)</li>
</ul>
</li>
<li>
<p>Generalities:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Don't use unsafe blocks (<a href="06_1_unsafe_generalities.html#LANG-UNSAFE">LANG-UNSAFE</a>)</li>
</ul>
</li>
<li>
<p>Memory management:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Do not use <code>forget</code> (<a href="06_2_unsafe_memory.html#MEM-FORGET">MEM-FORGET</a>)</li>
<li><input disabled="" type="checkbox"/>
Use clippy lint to detect use of <code>forget</code> (<a href="06_2_unsafe_memory.html#MEM-FORGET-LINT">MEM-FORGET-LINT</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not use <code>leak</code> function (<a href="06_2_unsafe_memory.html#MEM-LEAK">MEM-LEAK</a>)</li>
<li><input disabled="" type="checkbox"/>
Do release value wrapped in <code>ManuallyDrop</code> (<a href="06_2_unsafe_memory.html#MEM-MANUALLYDROP">MEM-MANUALLYDROP</a>)</li>
<li><input disabled="" type="checkbox"/>
Do no convert smart pointer into raw pointer in Rust without <code>unsafe</code> (<a href="06_2_unsafe_memory.html#MEM-NORAWPOINTER">MEM-NORAWPOINTER</a>)</li>
<li><input disabled="" type="checkbox"/>
Always call <code>from_raw</code> on <code>into_raw</code>ed value (<a href="06_2_unsafe_memory.html#MEM-INTOFROMRAW">MEM-INTOFROMRAW</a>)</li>
<li><input disabled="" type="checkbox"/>
Call <code>from_raw</code> <em>only</em> on <code>into_raw</code>ed value (<a href="06_2_unsafe_memory.html#MEM-INTOFROMRAW">MEM-INTOFROMRAW</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not use uninitialized memory (<a href="06_2_unsafe_memory.html#MEM-UNINIT">MEM-UNINIT</a>)</li>
<li><input disabled="" type="checkbox"/>
Avoid cyclic reference counted pointers (<a href="06_2_unsafe_memory.html#MEM-MUT-REC-RC">MEM-MUT-REC-RC</a>)</li>
</ul>
</li>
<li>
<p>Foreign Function Interface:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Use only C-compatible types in FFI (<a href="06_3_unsafe_ffi.html#FFI-CTYPE">FFI-CTYPE</a>)</li>
<li><input disabled="" type="checkbox"/>
Use consistent types at FFI boundaries (<a href="06_3_unsafe_ffi.html#FFI-TCONS">FFI-TCONS</a>)</li>
<li><input disabled="" type="checkbox"/>
Use automatic binding generator tools (<a href="06_3_unsafe_ffi.html#FFI-AUTOMATE">FFI-AUTOMATE</a>)</li>
<li><input disabled="" type="checkbox"/>
Use portable aliases <code>c_*</code> when binding to platform-dependent types (<a href="06_3_unsafe_ffi.html#FFI-PFTYPE">FFI-PFTYPE</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not use unchecked non-robust foreign values (<a href="06_3_unsafe_ffi.html#FFI-CKNONROBUST">FFI-CKNONROBUST</a>)</li>
<li><input disabled="" type="checkbox"/>
Check foreign values in Rust (<a href="06_3_unsafe_ffi.html#FFI-CKINRUST">FFI-CKINRUST</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not use reference types but pointer types (<a href="06_3_unsafe_ffi.html#FFI-NOREF">FFI-NOREF</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not use unchecked foreign references (<a href="06_3_unsafe_ffi.html#FFI-CKREF">FFI-CKREF</a>)</li>
<li><input disabled="" type="checkbox"/>
Check foreign pointers (<a href="06_3_unsafe_ffi.html#FFI-CKPTR">FFI-CKPTR</a>)</li>
<li><input disabled="" type="checkbox"/>
Mark function pointer types in FFI as <code>extern</code> and <code>unsafe</code> (<a href="06_3_unsafe_ffi.html#FFI-MARKEDFUNPTR">FFI-MARKEDFUNPTR</a>)</li>
<li><input disabled="" type="checkbox"/>
Check foreign function pointers (<a href="06_3_unsafe_ffi.html#FFI-CKFUNPTR">FFI-CKFUNPTR</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not use incoming Rust <code>enum</code> at FFI boundary (<a href="06_3_unsafe_ffi.html#FFI-NOENUM">FFI-NOENUM</a>)</li>
<li><input disabled="" type="checkbox"/>
Use dedicated Rust types for foreign opaque types (<a href="06_3_unsafe_ffi.html#FFI-R-OPAQUE">FFI-R-OPAQUE</a>)</li>
<li><input disabled="" type="checkbox"/>
Use incomplete C/C++ <code>struct</code> pointers to make type opaque (<a href="06_3_unsafe_ffi.html#FFI-C-OPAQUE">FFI-C-OPAQUE</a>)</li>
<li><input disabled="" type="checkbox"/>
Do not use types that implement <code>Drop</code> at FFI boundary (<a href="06_3_unsafe_ffi.html#FFI-MEM-NODROP">FFI-MEM-NODROP</a>)</li>
<li><input disabled="" type="checkbox"/>
Ensure clear data ownership in FFI (<a href="06_3_unsafe_ffi.html#FFI-MEM-OWNER">FFI-MEM-OWNER</a>)</li>
<li><input disabled="" type="checkbox"/>
Wrap foreign data in memory releasing wrapper (<a href="06_3_unsafe_ffi.html#FFI-MEM-WRAPPING">FFI-MEM-WRAPPING</a>)</li>
<li><input disabled="" type="checkbox"/>
Handle <code>panic!</code> correctly in FFI (<a href="06_3_unsafe_ffi.html#FFI-NOPANIC">FFI-NOPANIC</a>)</li>
<li><input disabled="" type="checkbox"/>
Provide safe wrapping to foreign library (<a href="06_3_unsafe_ffi.html#FFI-SAFEWRAPPING">FFI-SAFEWRAPPING</a>)</li>
<li><input disabled="" type="checkbox"/>
Expose dedicated C-compatible API only (<a href="06_3_unsafe_ffi.html#FFI-CAPI">FFI-CAPI</a>)</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
